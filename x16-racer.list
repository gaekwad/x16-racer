ca65 V2.18 - Git 4e3abf4
Main file   : x16-racer.asm
Current file: x16-racer.asm

000000r 1               ;=================================================
000000r 1               ;=================================================
000000r 1               ;
000000r 1               ;   Headers
000000r 1               ;
000000r 1               ;-------------------------------------------------
000000r 1               
000000r 1               .include "vera.inc"
000000r 2               
000000r 2               .ifndef VERA_INC
000000r 2               VERA_INC=1
000000r 2               
000000r 2               .include "system.inc"
000000r 3               .ifndef SYSTEM_INC
000000r 3               SYSTEM_INC=1
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_HEADER_0801
000000r 3               ;   File header of a PRG loaded at $0801. Includes
000000r 3               ;   encoded BASIC commands to start execution
000000r 3               ;   without needing a SYS() command.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   (none)
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: (none)
000000r 3               ;
000000r 3               .macro SYS_HEADER_0801
000000r 3                   .ifdef HEADER_A000_IN_USE
000000r 3                       .warning "SYS_HEADER_A000 already in use. This second call may not do what you think, and may break file size detection."
000000r 3                   .endif
000000r 3               
000000r 3                   HEADER_0801_IN_USE=1
000000r 3               
000000r 3               ;    .org $0801
000000r 3               ;    .byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00
000000r 3               
000000r 3                   .org $080D
000000r 3               
000000r 3                   .segment "STARTUP"
000000r 3                   .segment "INIT"
000000r 3                   .segment "ONCE"
000000r 3                   .segment "CODE"
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_HEADER_A000
000000r 3               ;   File header for a file loaded into $0A00. This
000000r 3               ;   may include executable code and/or data, but
000000r 3               ;   needs to be loaded in separate from the main
000000r 3               ;   .PRG because of the address it needs to occupy.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   (none)
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: (none)
000000r 3               ;
000000r 3               .macro SYS_HEADER_A000
000000r 3                   .ifdef HEADER_0801_IN_USE
000000r 3                       .warning "SYS_HEADER_0801 already in use. This second call may not do what you think, and may break file size detection."
000000r 3                   .endif
000000r 3               
000000r 3                   HEADER_A000_IN_USE=1
000000r 3               
000000r 3                   .org $0A00
000000r 3               
000000r 3                   .segment "STARTUP"
000000r 3                   .segment "INIT"
000000r 3                   .segment "ONCE"
000000r 3                   .segment "CODE"
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_FOOTER
000000r 3               ;   File footer for any file. This provides a warning
000000r 3               ;   in case the file has exceeded the bounds of
000000r 3               ;   the memory into which it is intended to be loaded.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   (none)
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: (none)
000000r 3               ;
000000r 3               .macro SYS_FOOTER
000000r 3                   .ifndef HEADER_0801_IN_USE
000000r 3                       .ifndef HEADER_A000_IN_USE
000000r 3                           .warning "SYS_HEADER_* macro in use. Add SYS_HEADER_0801 or SYS_HEADER_A000, depending on where you expect to load this file."
000000r 3                       .endif
000000r 3                   .endif
000000r 3               
000000r 3                   .ifdef HEADER_0801_IN_USE
000000r 3                       .if * > $9EFF
000000r 3                           .warning "Program size exceeds Fixed RAM space."
000000r 3                       .endif
000000r 3                   .endif
000000r 3               
000000r 3                   .ifdef HEADER_A000_IN_USE {
000000r 3                       .if * > $BFFF {
000000r 3                           .warning "Program size exceeds Fixed RAM space."
000000r 3                       .endif
000000r 3                   .endif
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ;=================================================
000000r 3               ;
000000r 3               ;   IRQ Handling
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_SET_IRQ
000000r 3               ;   Set where the kernal should jump to after
000000r 3               ;   its own interrupt handling.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   .address    Label or address of IRQ handler
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A
000000r 3               ;
000000r 3               .macro SYS_SET_IRQ address
000000r 3                   lda #<address
000000r 3                   sta $0314
000000r 3                   lda #>address
000000r 3                   sta $0315
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_END_IRQ
000000r 3               ;   Restore registers and return control to
000000r 3               ;   interrupted process.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   (none)
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A, X, Y
000000r 3               ;
000000r 3               .macro SYS_END_IRQ
000000r 3                   pla
000000r 3                   tay
000000r 3                   pla
000000r 3                   tax
000000r 3                   pla
000000r 3                   rti
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ;=================================================
000000r 3               ;
000000r 3               ;   Random number generation
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_RAND_SEED
000000r 3               ;   Seed the PRNG implementation with the selected
000000r 3               ;   values.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   (none)
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A
000000r 3               ;
000000r 3               .macro SYS_RAND_SEED v0, v1, v2
000000r 3                   lda #v0
000000r 3                   sta Sys_rand_mem
000000r 3                   lda #v1
000000r 3                   sta Sys_rand_mem+1
000000r 3                   lda #v2
000000r 3                   sta Sys_rand_mem+2
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ;=================================================
000000r 3               ;
000000r 3               ;   Copy macros
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_COPY
000000r 3               ;   Generic "copy a block of data from A to B" macro
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   src    Source address
000000r 3               ;           dst    Destination address
000000r 3               ;           size   Number of bytes to copy
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A, X, Y, $FB-$FF
000000r 3               ;
000000r 3               .macro SYS_COPY src, dst, size
000000r 3                   lda #<src ;src to $FC $FB
000000r 3                   sta $FB
000000r 3                   lda #>src
000000r 3                   sta $FC
000000r 3                   lda #<dst ;dst to $FE $FD
000000r 3                   sta $FD
000000r 3                   lda #>dst
000000r 3                   sta $FE
000000r 3                   .if size > $FF
000000r 3                                   ; If we have at least 1 full page to copy, then include the
000000r 3                                   ; page copy portion which needs a 5th byte to track the number
000000r 3                                   ; of pages to copy.
000000r 3               
000000r 3                       lda #>size ; number of pages to copy
000000r 3                       sta $FF
000000r 3               
000000r 3                       ldy #$00 ; reset y for our loop
000000r 3               
000000r 3               -       lda ($FB),Y ; indirect index source memory address
000000r 3                       sta ($FD),Y ; indirect index dest memory address
000000r 3                       iny
000000r 3                       bne :-       ; loop until our dest goes over 255
000000r 3               
000000r 3                       inc $FC     ; increment high order source memory address
000000r 3                       inc $FE     ; increment high order dest memory address
000000r 3               
000000r 3                       dec $FF     ; decrement number of pages remaining
000000r 3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000000r 3                   .endif
000000r 3                   .if <size > 0
000000r 3                                   ; If we're not copying exactly some number of pages, include
000000r 3                                   ; the "copy the rest of it" section
000000r 3                       ldy #0
000000r 3                       ldx #<size
000000r 3               
000000r 3               -       lda ($FB),Y
000000r 3                       sta ($FD),Y
000000r 3                       iny
000000r 3                       dex
000000r 3                       bne :-
000000r 3                   .endif
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_STREAM_OUT
000000r 3               ;   Copy a block of data starting at a source address,
000000r 3               ;   to exactly one destination address, because it's
000000r 3               ;   memory-mapped IO that will auto-increment its own
000000r 3               ;   destination.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   src    Source address
000000r 3               ;           dst    Destination address
000000r 3               ;           size   Number of bytes to copy
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A, X, Y, $FB-$FC, $FF
000000r 3               ;
000000r 3               .macro SYS_STREAM_OUT src, dst, size
000000r 3                   lda #<src ;src to $FC $FB
000000r 3                   sta $FB
000000r 3                   lda #>src
000000r 3                   sta $FC
000000r 3               
000000r 3                   .if size > $FF
000000r 3                                   ; If we have at least 1 full page to copy, then include the
000000r 3                                   ; page copy portion which needs a 5th byte to track the number
000000r 3                                   ; of pages to copy.
000000r 3               
000000r 3                       lda #>size ; number of pages to copy
000000r 3                       sta $FF
000000r 3               
000000r 3                       ldy #$00 ; reset y for our loop
000000r 3               
000000r 3               -       lda ($FB),Y ; indirect index source memory address
000000r 3                       sta dst
000000r 3                       iny
000000r 3                       bne :-       ; loop until our dest goes over 255
000000r 3               
000000r 3                       inc $FC     ; increment high order source memory address
000000r 3               
000000r 3                       dec $FF     ; decrement number of pages remaining
000000r 3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000000r 3                   .endif
000000r 3               
000000r 3                   .if <size > 0
000000r 3                                   ; If we're not copying exactly some number of pages, include
000000r 3                                   ; the "copy the rest of it" section
000000r 3                       ldy #0
000000r 3                       ldx #<size
000000r 3               
000000r 3               -       lda ($FB),Y
000000r 3                       sta dst
000000r 3                       iny
000000r 3                       dex
000000r 3                       bne :-
000000r 3                   .endif
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_STREAM_IN
000000r 3               ;   Copy a block of data from exactly one source address,
000000r 3               ;   because it's memory-mapped IO that will auto-increment
000000r 3               ;   its own source, to a destination starting at some address.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   src    Source address
000000r 3               ;           dst    Destination address
000000r 3               ;           size   Number of bytes to copy
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A, X, Y, $FD-$FF
000000r 3               ;
000000r 3               .macro SYS_STREAM_IN src, dst, size
000000r 3                   lda #<dst ;dst to $FE $FD
000000r 3                   sta $FD
000000r 3                   lda #>dst
000000r 3                   sta $FE
000000r 3               
000000r 3                   .if size > $FF
000000r 3                                   ; If we have at least 1 full page to copy, then include the
000000r 3                                   ; page copy portion which needs a 5th byte to track the number
000000r 3                                   ; of pages to copy.
000000r 3               
000000r 3                       lda #>size ; number of pages to copy
000000r 3                       sta $FF
000000r 3               
000000r 3                       ldy #$00 ; reset y for our loop
000000r 3               @loop:
000000r 3                       lda src
000000r 3                       sta ($FD),Y ; indirect index dest memory address
000000r 3                       iny
000000r 3                       bne @loop   ; loop until our dest goes over 255
000000r 3               
000000r 3                       inc $FE     ; increment high order dest memory address
000000r 3               
000000r 3                       dec $FF     ; decrement number of pages remaining
000000r 3                       bne @loop   ; If we still have at least 1 page to copy, go back and copy it
000000r 3                   .endif
000000r 3                   .if <size > 0
000000r 3                                   ; If we're not copying exactly some number of pages, include
000000r 3                                   ; the "copy the rest of it" section
000000r 3                       ldy #0
000000r 3                       ldx #<size
000000r 3               
000000r 3               -       lda src
000000r 3                       sta ($FD),Y
000000r 3                       iny
000000r 3                       dex
000000r 3                       bne :-
000000r 3                   .endif
000000r 3               .endmacro
000000r 3               
000000r 3               ;=================================================
000000r 3               ; SYS_STREAM
000000r 3               ;   Copy a block of data from exactly one source address,
000000r 3               ;   because it's memory-mapped IO that will auto-increment
000000r 3               ;   its own source, to exactly one destination address,
000000r 3               ;   because it too is memory-mapped IO.
000000r 3               ;-------------------------------------------------
000000r 3               ; INPUTS:   src    Source address
000000r 3               ;           dst    Destination address
000000r 3               ;           size   Number of bytes to copy
000000r 3               ;
000000r 3               ;-------------------------------------------------
000000r 3               ; MODIFIES: A, X, Y, $FF
000000r 3               ;
000000r 3               .macro SYS_STREAM src, dst, size
000000r 3                   .if size > $FF
000000r 3                                   ; If we have at least 1 full page to copy, then include the
000000r 3                                   ; page copy portion which needs a 5th byte to track the number
000000r 3                                   ; of pages to copy.
000000r 3               
000000r 3                       lda #>size ; number of pages to copy
000000r 3                       sta $FF
000000r 3               
000000r 3                       ldy #0 ; reset y for our loop
000000r 3               
000000r 3               -       lda src
000000r 3                       sta dst
000000r 3                       iny
000000r 3                       bne :-       ; loop until our dest goes over 255
000000r 3               
000000r 3                       dec $FF     ; decrement number of pages remaining
000000r 3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000000r 3                   .endif
000000r 3                   .if <size > 0
000000r 3                                   ; If we're not copying exactly some number of pages, include
000000r 3                                   ; the "copy the rest of it" section
000000r 3                       ldy #0
000000r 3                       ldx #<size
000000r 3               
000000r 3               -       lda src
000000r 3                       sta dst
000000r 3                       iny
000000r 3                       dex
000000r 3                       bne :-
000000r 3                   .endif
000000r 3               .endmacro
000000r 3               
000000r 3               .endif ; SYSTEM_INC
000000r 3               
000000r 2               
000000r 2               ;=================================================
000000r 2               ;=================================================
000000r 2               ;
000000r 2               ;   Memory-mapped registers
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               
000000r 2               .ifdef MACHINE_C64
000000r 2               	VERA_base = $df00
000000r 2               .else
000000r 2               	VERA_base = $9f20
000000r 2               .endif
000000r 2               
000000r 2               VERA_addr_low   = VERA_base+0
000000r 2               VERA_addr_high  = VERA_base+1
000000r 2               VERA_addr_bank  = VERA_base+2
000000r 2               VERA_data       = VERA_base+3
000000r 2               VERA_data2      = VERA_base+4
000000r 2               VERA_ctrl       = VERA_base+5
000000r 2               VERA_irq_ctrl   = VERA_base+6
000000r 2               VERA_irq        = VERA_base+7
000000r 2               
000000r 2               VRAM_composer  = $F0000
000000r 2               VRAM_palette   = $F1000
000000r 2               VRAM_layer1    = $F2000
000000r 2               VRAM_layer2    = $F3000
000000r 2               VRAM_sprinfo   = $F4000
000000r 2               VRAM_sprdata   = $F5800
000000r 2               
000000r 2               VRAM_palette0  = $F1000 + (2*16)*0
000000r 2               VRAM_palette1  = $F1000 + (2*16)*1
000000r 2               VRAM_palette2  = $F1000 + (2*16)*2
000000r 2               VRAM_palette3  = $F1000 + (2*16)*3
000000r 2               VRAM_palette4  = $F1000 + (2*16)*4
000000r 2               VRAM_palette5  = $F1000 + (2*16)*5
000000r 2               VRAM_palette6  = $F1000 + (2*16)*6
000000r 2               VRAM_palette7  = $F1000 + (2*16)*7
000000r 2               VRAM_palette8  = $F1000 + (2*16)*8
000000r 2               VRAM_palette9  = $F1000 + (2*16)*9
000000r 2               VRAM_palette10 = $F1000 + (2*16)*10
000000r 2               VRAM_palette11 = $F1000 + (2*16)*11
000000r 2               VRAM_palette12 = $F1000 + (2*16)*12
000000r 2               VRAM_palette13 = $F1000 + (2*16)*13
000000r 2               VRAM_palette14 = $F1000 + (2*16)*14
000000r 2               VRAM_palette15 = $F1000 + (2*16)*15
000000r 2               
000000r 2               VROM_petscii   = $1F000
000000r 2               
000000r 2               ;=================================================
000000r 2               ;=================================================
000000r 2               ;
000000r 2               ;   Macros
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_SELECT_ADDR
000000r 2               ;   Select which address channel to configure (VERA_data vs. VERA_data2)
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   addr	0 for VERA_data
000000r 2               ;					1 for VERA_data2
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_SELECT_ADDR addr
000000r 2               	lda #addr
000000r 2               	sta VERA_ctrl
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_SET_ADDR (multiple)
000000r 2               ;   Set the current address channel's address
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   addr			VRAM address to set to
000000r 2               ;			[stride = 1]	Address stride/auto-increment
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_SET_ADDR addr, stride
000000r 2               	.ifnblank stride
000000r 2               		lda #((^addr) | (stride << 4))
000000r 2               	.else
000000r 2               		lda #(^addr) | $10
000000r 2               	.endif
000000r 2               
000000r 2               	sta VERA_addr_bank
000000r 2               	lda #(>addr)
000000r 2               	sta VERA_addr_high
000000r 2               	lda #(<addr)
000000r 2               	sta VERA_addr_low
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_WRITE (multiple)
000000r 2               ;   Write values to VERA_data.
000000r 2               ;	If more than 8 values are needed, consider
000000r 2               ;	the SYS_STREAM_* family.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   v0 - v7	Values to write
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_WRITE v0, v1, v2, v3, v4, v5, v6, v7
000000r 2               	.ifblank v0
000000r 2               		.exitmacro
000000r 2               	.else
000000r 2               		lda #v0
000000r 2               		sta VERA_data
000000r 2               	.endif
000000r 2               
000000r 2               	.if .paramcount > 1
000000r 2               		VERA_WRITE v1, v2, v3, v4, v5, v6, v7
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VPEEK
000000r 2               ;   It's... VPEEK(), but in assembly.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   addr	VRAM address to read from.
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VPEEK addr
000000r 2               	VERA_SET_ADDR addr
000000r 2               	lda VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_ENABLE_LAYER
000000r 2               ;   Enable the specified layer
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   layer	Which layer to enable
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_ENABLE_LAYER layer
000000r 2               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000000r 2               	lda VERA_data
000000r 2               	ora #$01
000000r 2               	sta VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_DISABLE_LAYER
000000r 2               ;   Disable the specified layer
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   layer	Which layer to enable
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_DISABLE_LAYER layer
000000r 2               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000000r 2               	lda VERA_data
000000r 2               	and #$FE
000000r 2               	sta VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_CONFIGURE_TILE_LAYER
000000r 2               ;   Apply the given params to a layer.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   layer			Layer (0|1)
000000r 2               ;			enable			0: disable layer
000000r 2               ;							1: enable layer
000000r 2               ;			mode			0: text 1bpp, 16 color f/g
000000r 2               ;							1: text 1bpp, 256 color f
000000r 2               ;							2: tile 2bpp
000000r 2               ;							3: tile 4bpp
000000r 2               ;							4: tile 8bpp
000000r 2               ;			w16_tiles		(0|1) enable 16-width tiles?
000000r 2               ;			h16_tiles		(0|1) enable 16-height tiles?
000000r 2               ;			mapw, maph		0: 32 tiles/chars
000000r 2               ;							1: 64 tiles/chars
000000r 2               ;							2: 128 tiles/chars
000000r 2               ;							3: 256 tiles/chars
000000r 2               ;			map_base		Start address of map indices (4-byte align)
000000r 2               ;			tile_base		Start address of tile indices (4-byte align)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_CONFIGURE_TILE_LAYER layer, enable, mode, w16_tiles, h16_tiles, mapw, maph, map_base, tile_base
000000r 2               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000000r 2               
000000r 2               	; Mode
000000r 2               	lda #((mode << 5) | enable)
000000r 2               	sta VERA_data
000000r 2               
000000r 2               	; Tile and map size
000000r 2               	lda #((h16_tiles << 5) | (w16_tiles << 4) | (maph << 2) | (mapw))
000000r 2               	sta VERA_data
000000r 2               
000000r 2               .if (map_base & $FFFFFC) <> map_base
000000r 2               	.error "Map data does not obey alignment rules"
000000r 2               .endif
000000r 2               
000000r 2               .if (tile_base & $FFFFFC) <> tile_base
000000r 2               	.error "Tile data does not obey alignment rules"
000000r 2               .endif
000000r 2               
000000r 2               	; Map base
000000r 2               	lda #<(map_base >> 2)
000000r 2               	sta VERA_data
000000r 2               	lda #>(map_base >> 2)
000000r 2               	sta VERA_data
000000r 2               
000000r 2               	; Tile base
000000r 2               	lda #<(tile_base >> 2)
000000r 2               	sta VERA_data
000000r 2               	lda #>(tile_base >> 2)
000000r 2               	sta VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_CONFIGURE_BMP_LAYER
000000r 2               ;   Apply the given params to a layer.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   layer			Layer (0|1)
000000r 2               ;			mode			5: bitmap 2bpp
000000r 2               ;							6: bitmap 4bpp
000000r 2               ;							7: bitmap 8bpp
000000r 2               ;			h640			(0|1) enable 640p height?
000000r 2               ;			palette_offset	Which 16-color palette should it use?
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_CONFIGURE_BMP_LAYER layer, mode, h640, palette_offset
000000r 2               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000000r 2               
000000r 2               	; Mode
000000r 2               	lda #((mode << 5) | 1)
000000r 2               	sta VERA_data
000000r 2               
000000r 2               	; Tile and map size
000000r 2               	lda #(h640 << 8)
000000r 2               	sta VERA_data
000000r 2               
000000r 2               	; Palette offset
000000r 2               	lda #((layer << 4) | 7)
000000r 2               	sta VERA_addr_low
000000r 2               
000000r 2               	lda #((palette_offset) >> 4)
000000r 2               	sta VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_ENABLE_SPRITES
000000r 2               ;   Enables sprites layer
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_ENABLE_SPRITES
000000r 2                   VERA_SET_ADDR VRAM_sprinfo
000000r 2                   lda #1
000000r 2                   sta VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_DISABLE_SPRITES
000000r 2               ;   Disables sprites layer
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_DISABLE_SPRITES
000000r 2                   VERA_SET_ADDR VRAM_sprinfo
000000r 2                   lda #0
000000r 2                   sta VERA_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_SET_SPRITE
000000r 2               ;   Set the current address channel to target
000000r 2               ;	an indexed sprite_data entry in VRAM_sprdata
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   sprite_index	Sprite index to target
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_SET_SPRITE sprite_index
000000r 2               	VERA_SET_ADDR (VRAM_sprdata + (sprite_index << 3))
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_CONFIGURE_SPRITE
000000r 2               ;   Configure sprite data at the current sprite
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   data_addr	Location in VRAM where sprite data exists
000000r 2               ;			colors			0: 4bpp
000000r 2               ;							1: 8bpp
000000r 2               ;			xpos			X-position
000000r 2               ;			ypos			Y-position
000000r 2               ;			hflip			toggle horizontal flip
000000r 2               ;			vflip			toggle verticle flip
000000r 2               ;			zdepth			Z-depth of sprite
000000r 2               ;			palette_index	16-color-palette index selection
000000r 2               ;			width, height	0: 8px
000000r 2               ;							1: 16px
000000r 2               ;							2: 32px
000000r 2               ;							3: 64px
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_CONFIGURE_SPRITE data_addr, colors, xpos, ypos, hflip, vflip, zdepth, palette_index, width, height
000000r 2               .local DATA_ADDR
000000r 2               DATA_ADDR=(data_addr >> 5)
000000r 2               
000000r 2               .if ((DATA_ADDR << 5) <> data_addr)
000000r 2               	.error "Sprite data does not obey alignment rules"
000000r 2               .endif
000000r 2               
000000r 2               	VERA_WRITE <DATA_ADDR, >(DATA_ADDR | (colors << 7))
000000r 2               	VERA_WRITE <(xpos & $0FF), >(xpos & $300), <(ypos & $0FF), >(ypos & $300)
000000r 2               	VERA_WRITE	((hflip) | (vflip << 1) | (zdepth << 2))
000000r 2               	VERA_WRITE ((palette_index & $0F) | (width << 4) | (height << 6))
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_SET_PALETTE
000000r 2               ;   Set the current address channel to target
000000r 2               ;	an indexed palette  entry in VRAM_palette
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   palette_index		Palette index to target
000000r 2               ;			[.color_offset = 0]	Which color within the palette to target
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_SET_PALETTE palette_index, color_offset
000000r 2               	.ifblank color_offset
000000r 2               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5))
000000r 2               	.else
000000r 2               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5) + (color_offset << 1))
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_STREAM_OUT
000000r 2               ;   Stream out a block of data to a location in VRAM
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   src	Source data
000000r 2               ;			dst	Destination start location
000000r 2               ;			size	Numbers of bytes to stream out (max 64KiB)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A, X, Y, $FB, $FC
000000r 2               ;
000000r 2               .macro VERA_STREAM_OUT src, dst, size
000000r 2                   VERA_SET_ADDR dst
000000r 2                   ldy #<(size)
000000r 2                   ldx #>(size)
000000r 2                   lda #<src
000000r 2                   sta $FB
000000r 2                   lda #>src
000000r 2                   sta $FC
000000r 2                   jsr vera_stream_out_data
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_ENABLE_ALL
000000r 2               ;   Enables all layers and global sprites
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_ENABLE_ALL
000000r 2                   VERA_SET_ADDR VRAM_layer1, 13
000000r 2               	VERA_SELECT_ADDR 1
000000r 2                   VERA_SET_ADDR VRAM_layer1, 13
000000r 2               
000000r 2               	; Layer 0
000000r 2                   lda VERA_data
000000r 2                   ora #$01
000000r 2               	sta VERA_data2
000000r 2               
000000r 2               	; Layer 1
000000r 2                   lda VERA_data
000000r 2                   ora #$01
000000r 2               	sta VERA_data2
000000r 2               
000000r 2               	;Sprites
000000r 2                   lda VERA_data
000000r 2                   ora #$01
000000r 2               	sta VERA_data2
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_DISABLE_ALL
000000r 2               ;   Enables all layers and global sprites
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_DISABLE_ALL
000000r 2                   VERA_SET_ADDR VRAM_layer1, 13
000000r 2               	VERA_SELECT_ADDR 1
000000r 2                   VERA_SET_ADDR VRAM_layer1, 13
000000r 2               
000000r 2               	; Layer 0
000000r 2                   lda VERA_data
000000r 2                   and #$FE
000000r 2               	sta VERA_data2
000000r 2               
000000r 2               	; Layer 1
000000r 2                   lda VERA_data
000000r 2                   and #$FE
000000r 2               	sta VERA_data2
000000r 2               
000000r 2               	;Sprites
000000r 2                   lda VERA_data
000000r 2                   and #$FE
000000r 2               	sta VERA_data2
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_RESET
000000r 2               ;   Reset the Vera to its default settings.
000000r 2               ;	See official documentation for specifics.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_RESET
000000r 2               	lda #$80
000000r 2               	sta VERA_ctrl
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VERA_END_IRQ
000000r 2               ;   Reset the Vera IRQ flag so that it generates interrupts.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VERA_END_IRQ
000000r 2               	lda #$1
000000r 2               	sta VERA_irq
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; VIDEO_INIT
000000r 2               ;   Turn on the video display.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro VIDEO_INIT
000000r 2               	VERA_SELECT_ADDR 0
000000r 2               	VERA_SET_ADDR VRAM_composer, 1
000000r 2               	lda #1
000000r 2               	sta VERA_data ; VGA output
000000r 2               .endmacro
000000r 2               
000000r 2               .endif ; VERA_INC
000000r 2               
000000r 1               .include "system.inc"
000000r 2               .ifndef SYSTEM_INC
000000r 2               SYSTEM_INC=1
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_HEADER_0801
000000r 2               ;   File header of a PRG loaded at $0801. Includes
000000r 2               ;   encoded BASIC commands to start execution
000000r 2               ;   without needing a SYS() command.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: (none)
000000r 2               ;
000000r 2               .macro SYS_HEADER_0801
000000r 2                   .ifdef HEADER_A000_IN_USE
000000r 2                       .warning "SYS_HEADER_A000 already in use. This second call may not do what you think, and may break file size detection."
000000r 2                   .endif
000000r 2               
000000r 2                   HEADER_0801_IN_USE=1
000000r 2               
000000r 2               ;    .org $0801
000000r 2               ;    .byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00
000000r 2               
000000r 2                   .org $080D
000000r 2               
000000r 2                   .segment "STARTUP"
000000r 2                   .segment "INIT"
000000r 2                   .segment "ONCE"
000000r 2                   .segment "CODE"
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_HEADER_A000
000000r 2               ;   File header for a file loaded into $0A00. This
000000r 2               ;   may include executable code and/or data, but
000000r 2               ;   needs to be loaded in separate from the main
000000r 2               ;   .PRG because of the address it needs to occupy.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: (none)
000000r 2               ;
000000r 2               .macro SYS_HEADER_A000
000000r 2                   .ifdef HEADER_0801_IN_USE
000000r 2                       .warning "SYS_HEADER_0801 already in use. This second call may not do what you think, and may break file size detection."
000000r 2                   .endif
000000r 2               
000000r 2                   HEADER_A000_IN_USE=1
000000r 2               
000000r 2                   .org $0A00
000000r 2               
000000r 2                   .segment "STARTUP"
000000r 2                   .segment "INIT"
000000r 2                   .segment "ONCE"
000000r 2                   .segment "CODE"
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_FOOTER
000000r 2               ;   File footer for any file. This provides a warning
000000r 2               ;   in case the file has exceeded the bounds of
000000r 2               ;   the memory into which it is intended to be loaded.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: (none)
000000r 2               ;
000000r 2               .macro SYS_FOOTER
000000r 2                   .ifndef HEADER_0801_IN_USE
000000r 2                       .ifndef HEADER_A000_IN_USE
000000r 2                           .warning "SYS_HEADER_* macro in use. Add SYS_HEADER_0801 or SYS_HEADER_A000, depending on where you expect to load this file."
000000r 2                       .endif
000000r 2                   .endif
000000r 2               
000000r 2                   .ifdef HEADER_0801_IN_USE
000000r 2                       .if * > $9EFF
000000r 2                           .warning "Program size exceeds Fixed RAM space."
000000r 2                       .endif
000000r 2                   .endif
000000r 2               
000000r 2                   .ifdef HEADER_A000_IN_USE {
000000r 2                       .if * > $BFFF {
000000r 2                           .warning "Program size exceeds Fixed RAM space."
000000r 2                       .endif
000000r 2                   .endif
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ;=================================================
000000r 2               ;
000000r 2               ;   IRQ Handling
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_SET_IRQ
000000r 2               ;   Set where the kernal should jump to after
000000r 2               ;   its own interrupt handling.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   .address    Label or address of IRQ handler
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro SYS_SET_IRQ address
000000r 2                   lda #<address
000000r 2                   sta $0314
000000r 2                   lda #>address
000000r 2                   sta $0315
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_END_IRQ
000000r 2               ;   Restore registers and return control to
000000r 2               ;   interrupted process.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A, X, Y
000000r 2               ;
000000r 2               .macro SYS_END_IRQ
000000r 2                   pla
000000r 2                   tay
000000r 2                   pla
000000r 2                   tax
000000r 2                   pla
000000r 2                   rti
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ;=================================================
000000r 2               ;
000000r 2               ;   Random number generation
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_RAND_SEED
000000r 2               ;   Seed the PRNG implementation with the selected
000000r 2               ;   values.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   (none)
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A
000000r 2               ;
000000r 2               .macro SYS_RAND_SEED v0, v1, v2
000000r 2                   lda #v0
000000r 2                   sta Sys_rand_mem
000000r 2                   lda #v1
000000r 2                   sta Sys_rand_mem+1
000000r 2                   lda #v2
000000r 2                   sta Sys_rand_mem+2
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ;=================================================
000000r 2               ;
000000r 2               ;   Copy macros
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_COPY
000000r 2               ;   Generic "copy a block of data from A to B" macro
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   src    Source address
000000r 2               ;           dst    Destination address
000000r 2               ;           size   Number of bytes to copy
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A, X, Y, $FB-$FF
000000r 2               ;
000000r 2               .macro SYS_COPY src, dst, size
000000r 2                   lda #<src ;src to $FC $FB
000000r 2                   sta $FB
000000r 2                   lda #>src
000000r 2                   sta $FC
000000r 2                   lda #<dst ;dst to $FE $FD
000000r 2                   sta $FD
000000r 2                   lda #>dst
000000r 2                   sta $FE
000000r 2                   .if size > $FF
000000r 2                                   ; If we have at least 1 full page to copy, then include the
000000r 2                                   ; page copy portion which needs a 5th byte to track the number
000000r 2                                   ; of pages to copy.
000000r 2               
000000r 2                       lda #>size ; number of pages to copy
000000r 2                       sta $FF
000000r 2               
000000r 2                       ldy #$00 ; reset y for our loop
000000r 2               
000000r 2               -       lda ($FB),Y ; indirect index source memory address
000000r 2                       sta ($FD),Y ; indirect index dest memory address
000000r 2                       iny
000000r 2                       bne :-       ; loop until our dest goes over 255
000000r 2               
000000r 2                       inc $FC     ; increment high order source memory address
000000r 2                       inc $FE     ; increment high order dest memory address
000000r 2               
000000r 2                       dec $FF     ; decrement number of pages remaining
000000r 2                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000000r 2                   .endif
000000r 2                   .if <size > 0
000000r 2                                   ; If we're not copying exactly some number of pages, include
000000r 2                                   ; the "copy the rest of it" section
000000r 2                       ldy #0
000000r 2                       ldx #<size
000000r 2               
000000r 2               -       lda ($FB),Y
000000r 2                       sta ($FD),Y
000000r 2                       iny
000000r 2                       dex
000000r 2                       bne :-
000000r 2                   .endif
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_STREAM_OUT
000000r 2               ;   Copy a block of data starting at a source address,
000000r 2               ;   to exactly one destination address, because it's
000000r 2               ;   memory-mapped IO that will auto-increment its own
000000r 2               ;   destination.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   src    Source address
000000r 2               ;           dst    Destination address
000000r 2               ;           size   Number of bytes to copy
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A, X, Y, $FB-$FC, $FF
000000r 2               ;
000000r 2               .macro SYS_STREAM_OUT src, dst, size
000000r 2                   lda #<src ;src to $FC $FB
000000r 2                   sta $FB
000000r 2                   lda #>src
000000r 2                   sta $FC
000000r 2               
000000r 2                   .if size > $FF
000000r 2                                   ; If we have at least 1 full page to copy, then include the
000000r 2                                   ; page copy portion which needs a 5th byte to track the number
000000r 2                                   ; of pages to copy.
000000r 2               
000000r 2                       lda #>size ; number of pages to copy
000000r 2                       sta $FF
000000r 2               
000000r 2                       ldy #$00 ; reset y for our loop
000000r 2               
000000r 2               -       lda ($FB),Y ; indirect index source memory address
000000r 2                       sta dst
000000r 2                       iny
000000r 2                       bne :-       ; loop until our dest goes over 255
000000r 2               
000000r 2                       inc $FC     ; increment high order source memory address
000000r 2               
000000r 2                       dec $FF     ; decrement number of pages remaining
000000r 2                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000000r 2                   .endif
000000r 2               
000000r 2                   .if <size > 0
000000r 2                                   ; If we're not copying exactly some number of pages, include
000000r 2                                   ; the "copy the rest of it" section
000000r 2                       ldy #0
000000r 2                       ldx #<size
000000r 2               
000000r 2               -       lda ($FB),Y
000000r 2                       sta dst
000000r 2                       iny
000000r 2                       dex
000000r 2                       bne :-
000000r 2                   .endif
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_STREAM_IN
000000r 2               ;   Copy a block of data from exactly one source address,
000000r 2               ;   because it's memory-mapped IO that will auto-increment
000000r 2               ;   its own source, to a destination starting at some address.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   src    Source address
000000r 2               ;           dst    Destination address
000000r 2               ;           size   Number of bytes to copy
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A, X, Y, $FD-$FF
000000r 2               ;
000000r 2               .macro SYS_STREAM_IN src, dst, size
000000r 2                   lda #<dst ;dst to $FE $FD
000000r 2                   sta $FD
000000r 2                   lda #>dst
000000r 2                   sta $FE
000000r 2               
000000r 2                   .if size > $FF
000000r 2                                   ; If we have at least 1 full page to copy, then include the
000000r 2                                   ; page copy portion which needs a 5th byte to track the number
000000r 2                                   ; of pages to copy.
000000r 2               
000000r 2                       lda #>size ; number of pages to copy
000000r 2                       sta $FF
000000r 2               
000000r 2                       ldy #$00 ; reset y for our loop
000000r 2               @loop:
000000r 2                       lda src
000000r 2                       sta ($FD),Y ; indirect index dest memory address
000000r 2                       iny
000000r 2                       bne @loop   ; loop until our dest goes over 255
000000r 2               
000000r 2                       inc $FE     ; increment high order dest memory address
000000r 2               
000000r 2                       dec $FF     ; decrement number of pages remaining
000000r 2                       bne @loop   ; If we still have at least 1 page to copy, go back and copy it
000000r 2                   .endif
000000r 2                   .if <size > 0
000000r 2                                   ; If we're not copying exactly some number of pages, include
000000r 2                                   ; the "copy the rest of it" section
000000r 2                       ldy #0
000000r 2                       ldx #<size
000000r 2               
000000r 2               -       lda src
000000r 2                       sta ($FD),Y
000000r 2                       iny
000000r 2                       dex
000000r 2                       bne :-
000000r 2                   .endif
000000r 2               .endmacro
000000r 2               
000000r 2               ;=================================================
000000r 2               ; SYS_STREAM
000000r 2               ;   Copy a block of data from exactly one source address,
000000r 2               ;   because it's memory-mapped IO that will auto-increment
000000r 2               ;   its own source, to exactly one destination address,
000000r 2               ;   because it too is memory-mapped IO.
000000r 2               ;-------------------------------------------------
000000r 2               ; INPUTS:   src    Source address
000000r 2               ;           dst    Destination address
000000r 2               ;           size   Number of bytes to copy
000000r 2               ;
000000r 2               ;-------------------------------------------------
000000r 2               ; MODIFIES: A, X, Y, $FF
000000r 2               ;
000000r 2               .macro SYS_STREAM src, dst, size
000000r 2                   .if size > $FF
000000r 2                                   ; If we have at least 1 full page to copy, then include the
000000r 2                                   ; page copy portion which needs a 5th byte to track the number
000000r 2                                   ; of pages to copy.
000000r 2               
000000r 2                       lda #>size ; number of pages to copy
000000r 2                       sta $FF
000000r 2               
000000r 2                       ldy #0 ; reset y for our loop
000000r 2               
000000r 2               -       lda src
000000r 2                       sta dst
000000r 2                       iny
000000r 2                       bne :-       ; loop until our dest goes over 255
000000r 2               
000000r 2                       dec $FF     ; decrement number of pages remaining
000000r 2                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000000r 2                   .endif
000000r 2                   .if <size > 0
000000r 2                                   ; If we're not copying exactly some number of pages, include
000000r 2                                   ; the "copy the rest of it" section
000000r 2                       ldy #0
000000r 2                       ldx #<size
000000r 2               
000000r 2               -       lda src
000000r 2                       sta dst
000000r 2                       iny
000000r 2                       dex
000000r 2                       bne :-
000000r 2                   .endif
000000r 2               .endmacro
000000r 2               
000000r 2               .endif ; SYSTEM_INC
000000r 2               
000000r 1               
000000r 1               ;=================================================
000000r 1               ; Macros
000000r 1               ;
000000r 1               ;-------------------------------------------------
000000r 1               
000000r 1               DEFAULT_SCREEN_ADDR = 0
000000r 1               DEFAULT_SCREEN_SIZE = (128*64)*2
000000r 1               
000000r 1               ;=================================================
000000r 1               ; MOD
000000r 1               ;   Module the accumulator by a value.
000000r 1               ;-------------------------------------------------
000000r 1               ; INPUTS:   .v  Divisor of the modulo
000000r 1               ;
000000r 1               ;-------------------------------------------------
000000r 1               ; MODIFIES: A
000000r 1               ;
000000r 1               .macro MOD v
000000r 1               .local @sub
000000r 1               @sub:
000000r 1                   sec
000000r 1                   sbc #v
000000r 1                   bcs @sub
000000r 1                   adc #v
000000r 1               .endscope
000000r 1               .endmacro
000000r 1               
000000r 1               SYS_HEADER_0801
00080D  1               
00080D  1               ;=================================================
00080D  1               ;=================================================
00080D  1               ;
00080D  1               ;   main code
00080D  1               ;
00080D  1               ;-------------------------------------------------
00080D  1               start:
00080D  1  A9 34 8D D1      SYS_RAND_SEED $34, $56, $fe
000811  1  98 A9 56 8D  
000815  1  D2 98 A9 FE  
00081C  1               
00081C  1  20 08 0A         jsr graphics_fade_out
00081F  1  20 F1 0B         jsr splash_do
000822  1  20 BD 0C         jsr race_do
000825  1               
000825  1                   ;
000825  1                   ; Palette memory should now be all 0s, or a black screen.
000825  1                   ; If only the composer gave us a brightness setting, I could
000825  1                   ; have used that. Mei banfa.
000825  1                   ;
000825  1               
000825  1  A9 00 8D 25      VERA_SELECT_ADDR 0
000829  1  9F           
00082A  1               
00082A  1  A9 1F 8D 22      VERA_SET_ADDR VRAM_layer1
00082E  1  9F A9 20 8D  
000832  1  21 9F A9 00  
000839  1  A9 21 8D 23      VERA_WRITE ($01 << 5) | $01            ; Mode 1 (256-color text), enabled
00083D  1  9F           
00083E  1  A9 06 8D 23      VERA_WRITE %00000110                   ; 8x8 tiles, 128x64 map
000842  1  9F           
000843  1  A9 00 8D 23      VERA_WRITE <(DEFAULT_SCREEN_ADDR >> 2) ; Map indices at VRAM address 0
000847  1  9F           
000848  1  A9 00 8D 23      VERA_WRITE >(DEFAULT_SCREEN_ADDR >> 2) ;
00084C  1  9F           
00084D  1  A9 00 8D 23      VERA_WRITE <(VROM_petscii >> 2)        ; Tile data immediately after map indices
000851  1  9F           
000852  1  A9 7C 8D 23      VERA_WRITE >(VROM_petscii >> 2)        ; Tile data immediately after map indices
000856  1  9F           
000857  1  A9 00 8D 23      VERA_WRITE 0, 0, 0, 0                  ; Hscroll and VScroll to 0
00085B  1  9F A9 00 8D  
00085F  1  23 9F A9 00  
00086B  1               
00086B  1               __start__fill_text_buffer_with_random_chars:
00086B  1  A9 20 8D 22      VERA_SET_ADDR DEFAULT_SCREEN_ADDR, 2
00086F  1  9F A9 00 8D  
000873  1  21 9F A9 00  
00087A  1               
00087A  1  A2 80            ldx #128
00087C  1  A0 40            ldy #64
00087E  1               
00087E  1               @yloop:
00087E  1  98               tya
00087F  1  48               pha
000880  1               @xloop:
000880  1  8A               txa
000881  1               
000881  1  20 C4 09         jsr sys_rand
000884  1  29 7F            and #$7F
000886  1  A8               tay
000887  1               
000887  1  B9 D0 8F         lda Petscii_table,Y
00088A  1  8D 23 9F         sta VERA_data
00088D  1               
00088D  1  AA               tax
00088E  1  CA               dex
00088F  1  D0 EF            bne @xloop
000891  1               
000891  1  68               pla
000892  1  A8               tay
000893  1  88               dey
000894  1  D0 E8            bne @yloop
000896  1               
000896  1               __start__offset_palette_of_each_column:
000896  1  A9 21 8D 22      VERA_SET_ADDR DEFAULT_SCREEN_ADDR+1, 2
00089A  1  9F A9 01 8D  
00089E  1  21 9F A9 01  
0008A5  1               
0008A5  1  A9 80            lda #128
0008A7  1               
0008A7  1               @xloop:
0008A7  1  48               pha
0008A8  1               
0008A8  1  20 C4 09         jsr sys_rand
0008AB  1                   ; If we're about to assign palette index 0 (background), increment to 1
0008AB  1  C9 00            cmp #0
0008AD  1  F0 03            beq :+
0008AF  1  18               clc
0008B0  1  69 01            adc #1
0008B2  1  8D 23 9F     :   sta VERA_data
0008B5  1               
0008B5  1  68               pla
0008B6  1  38               sec
0008B7  1  E9 01            sbc #1
0008B9  1  D0 EC            bne @xloop
0008BB  1               
0008BB  1               __start__fill_palette_of_remaining_chars:
0008BB  1  A9 20 8D 22      VERA_SET_ADDR (DEFAULT_SCREEN_ADDR+1), 2
0008BF  1  9F A9 00 8D  
0008C3  1  21 9F A9 01  
0008CA  1  A9 01 8D 25      VERA_SELECT_ADDR 1
0008CE  1  9F           
0008CF  1  A9 20 8D 22      VERA_SET_ADDR (DEFAULT_SCREEN_ADDR+257), 2
0008D3  1  9F A9 01 8D  
0008D7  1  21 9F A9 01  
0008DE  1  A9 00 8D 25      VERA_SELECT_ADDR 0
0008E2  1  9F           
0008E3  1               
0008E3  1  A2 7F            ldx #127
0008E5  1  A0 40            ldy #64
0008E7  1               
0008E7  1               @yloop:
0008E7  1  98               tya
0008E8  1  48               pha
0008E9  1               @xloop:
0008E9  1  8A               txa
0008EA  1  48               pha
0008EB  1               
0008EB  1  AD 23 9F         lda VERA_data
0008EE  1  18               clc
0008EF  1  69 01            adc #1
0008F1  1                   ; If we're about to assign palette index 0 (background), increment to 1
0008F1  1  C9 00            cmp #0
0008F3  1  D0 03            bne :+
0008F5  1  18               clc
0008F6  1  69 01            adc #1
0008F8  1  8D 24 9F     :   sta VERA_data2
0008FB  1               
0008FB  1  68               pla
0008FC  1  AA               tax
0008FD  1  CA               dex
0008FE  1  D0 E9            bne @xloop
000900  1               
000900  1  68               pla
000901  1  A8               tay
000902  1  88               dey
000903  1  D0 E2            bne @yloop
000905  1               
000905  1               
000905  1  A9 50            lda #<Matrix_palette
000907  1  85 FB            sta $FB
000909  1  A9 90            lda #>Matrix_palette
00090B  1  85 FC            sta $FC
00090D  1  A9 1F            lda #((Matrix_palette_end - Matrix_palette) >> 1)
00090F  1  85 FD            sta $FD
000911  1  20 6B 0A         jsr graphics_fade_in
000914  1               
000914  1  A9 22 8D 14      SYS_SET_IRQ irq_handler
000918  1  03 A9 09 8D  
00091C  1  15 03        
00091E  1  58               cli
00091F  1               
00091F  1  4C 1F 09         jmp *
000922  1               
000922  1                   ; +VERA_RESET
000922  1               
000922  1               ;=================================================
000922  1               ;=================================================
000922  1               ;
000922  1               ;   IRQ Handlers
000922  1               ;
000922  1               ;-------------------------------------------------
000922  1               
000922  1               ;=================================================
000922  1               ; irq_handler
000922  1               ;   This is essentially my "do_frame". Several others have been doing this as well.
000922  1               ;   Since the IRQ is triggered at the beginning of the VGA/NTSA front porch, we don't
000922  1               ;   get the benefit of the entire VBLANK, but it's still useful as a "do this code
000922  1               ;   once per frame" function.
000922  1               ;-------------------------------------------------
000922  1               ; INPUTS: (none)
000922  1               ;
000922  1               ;-------------------------------------------------
000922  1               ; MODIFIES: A, X, Y, VRAM_palette
000922  1               ;
000922  1               irq_handler:
000922  1  A9 00 8D 25      VERA_SELECT_ADDR 0
000926  1  9F           
000927  1               
000927  1                   ; Increment which palette index we're starting at
000927  1  AD CC 90         lda Palette_cycle_index
00092A  1  18               clc
00092B  1  69 01            adc #1
00092D  1                   ; Skip index zero, that's the background, we want to leave it black.
00092D  1  69 00            adc #0
00092F  1  8D CC 90         sta Palette_cycle_index
000932  1               
000932  1               ;
000932  1               ; Palette cycle for the letters glowing and stuff
000932  1               ;
000932  1               
000932  1                   ; Set the starting address of the VRAM palette we're going to cycle
000932  1  0A               asl ; Palette_cycle_index * 2 == Address offset into palette memory
000933  1                   ; adc #<(VRAM_palette) ; We happen to know that #<(VRAM_palette) is 0. Being able to skip this also preserves Carry in case it was set
000933  1  8D 20 9F         sta VERA_addr_low
000936  1  A9 10            lda #<(VRAM_palette >> 8)
000938  1  69 00            adc #0  ; Add carry bit for indices 128-255
00093A  1  8D 21 9F         sta VERA_addr_high
00093D  1  A9 1F            lda #<(VRAM_palette >> 16) | (1 << 4)
00093F  1  8D 22 9F         sta VERA_addr_bank
000942  1               
000942  1  A9 50            lda #<Matrix_palette
000944  1  85 FB            sta $FB
000946  1  A9 90            lda #>Matrix_palette
000948  1  85 FC            sta $FC
00094A  1               
00094A  1  AE CC 90         ldx Palette_cycle_index
00094D  1  A0 00            ldy #0
00094F  1               
00094F  1  B1 FB        :   lda ($FB),Y
000951  1  8D 23 9F         sta VERA_data
000954  1  C8               iny
000955  1  B1 FB            lda ($FB),Y
000957  1  8D 23 9F         sta VERA_data
00095A  1  C8               iny
00095B  1  E8               inx
00095C  1  D0 0F            bne :+
00095E  1  A9 1F 8D 22      VERA_SET_PALETTE 0, 1
000962  1  9F A9 10 8D  
000966  1  21 9F A9 02  
00096D  1  C0 3E        :   cpy #(Matrix_palette_end - Matrix_palette)
00096F  1  D0 DE            bne :--
000971  1               
000971  1               ;
000971  1               ; Palette cycle (redux) for double-density!
000971  1               ;
000971  1  AD CC 90         lda Palette_cycle_index
000974  1  69 7F            adc #127
000976  1  18               clc
000977  1               
000977  1                   ; Set the starting address of the VRAM palette we're going to cycle
000977  1  0A               asl ; Palette_cycle_index * 2 == Address offset into palette memory
000978  1                   ; adc #<(VRAM_palette) ; We happen to know that #<(VRAM_palette) is 0. Being able to skip this also preserves Carry in case it was set
000978  1  8D 20 9F         sta VERA_addr_low
00097B  1  A9 10            lda #<(VRAM_palette >> 8)
00097D  1  69 00            adc #0  ; Add carry bit for indices 128-255
00097F  1  8D 21 9F         sta VERA_addr_high
000982  1  A9 1F            lda #<(VRAM_palette >> 16) | (1 << 4)
000984  1  8D 22 9F         sta VERA_addr_bank
000987  1               
000987  1  A9 50            lda #<Matrix_palette
000989  1  85 FB            sta $FB
00098B  1  A9 90            lda #>Matrix_palette
00098D  1  85 FC            sta $FC
00098F  1               
00098F  1  AD CC 90         lda Palette_cycle_index
000992  1  69 80            adc #128
000994  1  AA               tax
000995  1  A0 00            ldy #0
000997  1               
000997  1  B1 FB        :   lda ($FB),Y
000999  1  8D 23 9F         sta VERA_data
00099C  1  C8               iny
00099D  1  B1 FB            lda ($FB),Y
00099F  1  8D 23 9F         sta VERA_data
0009A2  1  C8               iny
0009A3  1  E8               inx
0009A4  1  D0 0F            bne :+
0009A6  1  A9 1F 8D 22      VERA_SET_PALETTE 0, 1
0009AA  1  9F A9 10 8D  
0009AE  1  21 9F A9 02  
0009B5  1  C0 3E        :   cpy #(Matrix_palette_end - Matrix_palette)
0009B7  1  D0 DE            bne :--
0009B9  1               
0009B9  1  A9 01 8D 27      VERA_END_IRQ
0009BD  1  9F           
0009BE  1  68 A8 68 AA      SYS_END_IRQ
0009C2  1  68 40        
0009C4  1               
0009C4  1               ;=================================================
0009C4  1               ;=================================================
0009C4  1               ;
0009C4  1               ;   Miscellaneous data copying
0009C4  1               ;
0009C4  1               ;-------------------------------------------------
0009C4  1               ;
0009C4  1               ; I wasn't sure what to do with this. I already have
0009C4  1               ; SYS_STREAM_OUT, but I basically needed it for
0009C4  1               ; a source address and quantity of data that can
0009C4  1               ; only be determined at run-time. I'm I'll eventually
0009C4  1               ; convert this into some kind of other
0009C4  1               ; SYS_STREAM_OUT-like macro, so that I can
0009C4  1               ; easily declare function definitions for a variety
0009C4  1               ; of fixed destinations, and then come back and do
0009C4  1               ; the same for fixed sources with runtime destinations
0009C4  1               ; and of course a function to just handle everything
0009C4  1               ; being runtime data.
0009C4  1               ;
0009C4  1               
0009C4  1               ;=================================================
0009C4  1               ;=================================================
0009C4  1               ;
0009C4  1               ;   Libs
0009C4  1               ;
0009C4  1               ;-------------------------------------------------
0009C4  1               .include "system.asm"
0009C4  2               .ifndef SYSTEM_ASM
0009C4  2               SYSTEM_ASM=1
0009C4  2               
0009C4  2               .include "system.inc"
0009C4  3               .ifndef SYSTEM_INC
0009C4  3               SYSTEM_INC=1
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_HEADER_0801
0009C4  3               ;   File header of a PRG loaded at $0801. Includes
0009C4  3               ;   encoded BASIC commands to start execution
0009C4  3               ;   without needing a SYS() command.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: (none)
0009C4  3               ;
0009C4  3               .macro SYS_HEADER_0801
0009C4  3                   .ifdef HEADER_A000_IN_USE
0009C4  3                       .warning "SYS_HEADER_A000 already in use. This second call may not do what you think, and may break file size detection."
0009C4  3                   .endif
0009C4  3               
0009C4  3                   HEADER_0801_IN_USE=1
0009C4  3               
0009C4  3               ;    .org $0801
0009C4  3               ;    .byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00
0009C4  3               
0009C4  3                   .org $080D
0009C4  3               
0009C4  3                   .segment "STARTUP"
0009C4  3                   .segment "INIT"
0009C4  3                   .segment "ONCE"
0009C4  3                   .segment "CODE"
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_HEADER_A000
0009C4  3               ;   File header for a file loaded into $0A00. This
0009C4  3               ;   may include executable code and/or data, but
0009C4  3               ;   needs to be loaded in separate from the main
0009C4  3               ;   .PRG because of the address it needs to occupy.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: (none)
0009C4  3               ;
0009C4  3               .macro SYS_HEADER_A000
0009C4  3                   .ifdef HEADER_0801_IN_USE
0009C4  3                       .warning "SYS_HEADER_0801 already in use. This second call may not do what you think, and may break file size detection."
0009C4  3                   .endif
0009C4  3               
0009C4  3                   HEADER_A000_IN_USE=1
0009C4  3               
0009C4  3                   .org $0A00
0009C4  3               
0009C4  3                   .segment "STARTUP"
0009C4  3                   .segment "INIT"
0009C4  3                   .segment "ONCE"
0009C4  3                   .segment "CODE"
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_FOOTER
0009C4  3               ;   File footer for any file. This provides a warning
0009C4  3               ;   in case the file has exceeded the bounds of
0009C4  3               ;   the memory into which it is intended to be loaded.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: (none)
0009C4  3               ;
0009C4  3               .macro SYS_FOOTER
0009C4  3                   .ifndef HEADER_0801_IN_USE
0009C4  3                       .ifndef HEADER_A000_IN_USE
0009C4  3                           .warning "SYS_HEADER_* macro in use. Add SYS_HEADER_0801 or SYS_HEADER_A000, depending on where you expect to load this file."
0009C4  3                       .endif
0009C4  3                   .endif
0009C4  3               
0009C4  3                   .ifdef HEADER_0801_IN_USE
0009C4  3                       .if * > $9EFF
0009C4  3                           .warning "Program size exceeds Fixed RAM space."
0009C4  3                       .endif
0009C4  3                   .endif
0009C4  3               
0009C4  3                   .ifdef HEADER_A000_IN_USE {
0009C4  3                       .if * > $BFFF {
0009C4  3                           .warning "Program size exceeds Fixed RAM space."
0009C4  3                       .endif
0009C4  3                   .endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ;=================================================
0009C4  3               ;
0009C4  3               ;   IRQ Handling
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_SET_IRQ
0009C4  3               ;   Set where the kernal should jump to after
0009C4  3               ;   its own interrupt handling.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   .address    Label or address of IRQ handler
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro SYS_SET_IRQ address
0009C4  3                   lda #<address
0009C4  3                   sta $0314
0009C4  3                   lda #>address
0009C4  3                   sta $0315
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_END_IRQ
0009C4  3               ;   Restore registers and return control to
0009C4  3               ;   interrupted process.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A, X, Y
0009C4  3               ;
0009C4  3               .macro SYS_END_IRQ
0009C4  3                   pla
0009C4  3                   tay
0009C4  3                   pla
0009C4  3                   tax
0009C4  3                   pla
0009C4  3                   rti
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ;=================================================
0009C4  3               ;
0009C4  3               ;   Random number generation
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_RAND_SEED
0009C4  3               ;   Seed the PRNG implementation with the selected
0009C4  3               ;   values.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro SYS_RAND_SEED v0, v1, v2
0009C4  3                   lda #v0
0009C4  3                   sta Sys_rand_mem
0009C4  3                   lda #v1
0009C4  3                   sta Sys_rand_mem+1
0009C4  3                   lda #v2
0009C4  3                   sta Sys_rand_mem+2
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ;=================================================
0009C4  3               ;
0009C4  3               ;   Copy macros
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_COPY
0009C4  3               ;   Generic "copy a block of data from A to B" macro
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   src    Source address
0009C4  3               ;           dst    Destination address
0009C4  3               ;           size   Number of bytes to copy
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A, X, Y, $FB-$FF
0009C4  3               ;
0009C4  3               .macro SYS_COPY src, dst, size
0009C4  3                   lda #<src ;src to $FC $FB
0009C4  3                   sta $FB
0009C4  3                   lda #>src
0009C4  3                   sta $FC
0009C4  3                   lda #<dst ;dst to $FE $FD
0009C4  3                   sta $FD
0009C4  3                   lda #>dst
0009C4  3                   sta $FE
0009C4  3                   .if size > $FF
0009C4  3                                   ; If we have at least 1 full page to copy, then include the
0009C4  3                                   ; page copy portion which needs a 5th byte to track the number
0009C4  3                                   ; of pages to copy.
0009C4  3               
0009C4  3                       lda #>size ; number of pages to copy
0009C4  3                       sta $FF
0009C4  3               
0009C4  3                       ldy #$00 ; reset y for our loop
0009C4  3               
0009C4  3               -       lda ($FB),Y ; indirect index source memory address
0009C4  3                       sta ($FD),Y ; indirect index dest memory address
0009C4  3                       iny
0009C4  3                       bne :-       ; loop until our dest goes over 255
0009C4  3               
0009C4  3                       inc $FC     ; increment high order source memory address
0009C4  3                       inc $FE     ; increment high order dest memory address
0009C4  3               
0009C4  3                       dec $FF     ; decrement number of pages remaining
0009C4  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
0009C4  3                   .endif
0009C4  3                   .if <size > 0
0009C4  3                                   ; If we're not copying exactly some number of pages, include
0009C4  3                                   ; the "copy the rest of it" section
0009C4  3                       ldy #0
0009C4  3                       ldx #<size
0009C4  3               
0009C4  3               -       lda ($FB),Y
0009C4  3                       sta ($FD),Y
0009C4  3                       iny
0009C4  3                       dex
0009C4  3                       bne :-
0009C4  3                   .endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_STREAM_OUT
0009C4  3               ;   Copy a block of data starting at a source address,
0009C4  3               ;   to exactly one destination address, because it's
0009C4  3               ;   memory-mapped IO that will auto-increment its own
0009C4  3               ;   destination.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   src    Source address
0009C4  3               ;           dst    Destination address
0009C4  3               ;           size   Number of bytes to copy
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A, X, Y, $FB-$FC, $FF
0009C4  3               ;
0009C4  3               .macro SYS_STREAM_OUT src, dst, size
0009C4  3                   lda #<src ;src to $FC $FB
0009C4  3                   sta $FB
0009C4  3                   lda #>src
0009C4  3                   sta $FC
0009C4  3               
0009C4  3                   .if size > $FF
0009C4  3                                   ; If we have at least 1 full page to copy, then include the
0009C4  3                                   ; page copy portion which needs a 5th byte to track the number
0009C4  3                                   ; of pages to copy.
0009C4  3               
0009C4  3                       lda #>size ; number of pages to copy
0009C4  3                       sta $FF
0009C4  3               
0009C4  3                       ldy #$00 ; reset y for our loop
0009C4  3               
0009C4  3               -       lda ($FB),Y ; indirect index source memory address
0009C4  3                       sta dst
0009C4  3                       iny
0009C4  3                       bne :-       ; loop until our dest goes over 255
0009C4  3               
0009C4  3                       inc $FC     ; increment high order source memory address
0009C4  3               
0009C4  3                       dec $FF     ; decrement number of pages remaining
0009C4  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
0009C4  3                   .endif
0009C4  3               
0009C4  3                   .if <size > 0
0009C4  3                                   ; If we're not copying exactly some number of pages, include
0009C4  3                                   ; the "copy the rest of it" section
0009C4  3                       ldy #0
0009C4  3                       ldx #<size
0009C4  3               
0009C4  3               -       lda ($FB),Y
0009C4  3                       sta dst
0009C4  3                       iny
0009C4  3                       dex
0009C4  3                       bne :-
0009C4  3                   .endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_STREAM_IN
0009C4  3               ;   Copy a block of data from exactly one source address,
0009C4  3               ;   because it's memory-mapped IO that will auto-increment
0009C4  3               ;   its own source, to a destination starting at some address.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   src    Source address
0009C4  3               ;           dst    Destination address
0009C4  3               ;           size   Number of bytes to copy
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A, X, Y, $FD-$FF
0009C4  3               ;
0009C4  3               .macro SYS_STREAM_IN src, dst, size
0009C4  3                   lda #<dst ;dst to $FE $FD
0009C4  3                   sta $FD
0009C4  3                   lda #>dst
0009C4  3                   sta $FE
0009C4  3               
0009C4  3                   .if size > $FF
0009C4  3                                   ; If we have at least 1 full page to copy, then include the
0009C4  3                                   ; page copy portion which needs a 5th byte to track the number
0009C4  3                                   ; of pages to copy.
0009C4  3               
0009C4  3                       lda #>size ; number of pages to copy
0009C4  3                       sta $FF
0009C4  3               
0009C4  3                       ldy #$00 ; reset y for our loop
0009C4  3               @loop:
0009C4  3                       lda src
0009C4  3                       sta ($FD),Y ; indirect index dest memory address
0009C4  3                       iny
0009C4  3                       bne @loop   ; loop until our dest goes over 255
0009C4  3               
0009C4  3                       inc $FE     ; increment high order dest memory address
0009C4  3               
0009C4  3                       dec $FF     ; decrement number of pages remaining
0009C4  3                       bne @loop   ; If we still have at least 1 page to copy, go back and copy it
0009C4  3                   .endif
0009C4  3                   .if <size > 0
0009C4  3                                   ; If we're not copying exactly some number of pages, include
0009C4  3                                   ; the "copy the rest of it" section
0009C4  3                       ldy #0
0009C4  3                       ldx #<size
0009C4  3               
0009C4  3               -       lda src
0009C4  3                       sta ($FD),Y
0009C4  3                       iny
0009C4  3                       dex
0009C4  3                       bne :-
0009C4  3                   .endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; SYS_STREAM
0009C4  3               ;   Copy a block of data from exactly one source address,
0009C4  3               ;   because it's memory-mapped IO that will auto-increment
0009C4  3               ;   its own source, to exactly one destination address,
0009C4  3               ;   because it too is memory-mapped IO.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   src    Source address
0009C4  3               ;           dst    Destination address
0009C4  3               ;           size   Number of bytes to copy
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A, X, Y, $FF
0009C4  3               ;
0009C4  3               .macro SYS_STREAM src, dst, size
0009C4  3                   .if size > $FF
0009C4  3                                   ; If we have at least 1 full page to copy, then include the
0009C4  3                                   ; page copy portion which needs a 5th byte to track the number
0009C4  3                                   ; of pages to copy.
0009C4  3               
0009C4  3                       lda #>size ; number of pages to copy
0009C4  3                       sta $FF
0009C4  3               
0009C4  3                       ldy #0 ; reset y for our loop
0009C4  3               
0009C4  3               -       lda src
0009C4  3                       sta dst
0009C4  3                       iny
0009C4  3                       bne :-       ; loop until our dest goes over 255
0009C4  3               
0009C4  3                       dec $FF     ; decrement number of pages remaining
0009C4  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
0009C4  3                   .endif
0009C4  3                   .if <size > 0
0009C4  3                                   ; If we're not copying exactly some number of pages, include
0009C4  3                                   ; the "copy the rest of it" section
0009C4  3                       ldy #0
0009C4  3                       ldx #<size
0009C4  3               
0009C4  3               -       lda src
0009C4  3                       sta dst
0009C4  3                       iny
0009C4  3                       dex
0009C4  3                       bne :-
0009C4  3                   .endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               .endif ; SYSTEM_INC
0009C4  3               
0009C4  2               .include "vera.inc"
0009C4  3               
0009C4  3               .ifndef VERA_INC
0009C4  3               VERA_INC=1
0009C4  3               
0009C4  3               .include "system.inc"
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ;=================================================
0009C4  3               ;
0009C4  3               ;   Memory-mapped registers
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               
0009C4  3               .ifdef MACHINE_C64
0009C4  3               	VERA_base = $df00
0009C4  3               .else
0009C4  3               	VERA_base = $9f20
0009C4  3               .endif
0009C4  3               
0009C4  3               VERA_addr_low   = VERA_base+0
0009C4  3               VERA_addr_high  = VERA_base+1
0009C4  3               VERA_addr_bank  = VERA_base+2
0009C4  3               VERA_data       = VERA_base+3
0009C4  3               VERA_data2      = VERA_base+4
0009C4  3               VERA_ctrl       = VERA_base+5
0009C4  3               VERA_irq_ctrl   = VERA_base+6
0009C4  3               VERA_irq        = VERA_base+7
0009C4  3               
0009C4  3               VRAM_composer  = $F0000
0009C4  3               VRAM_palette   = $F1000
0009C4  3               VRAM_layer1    = $F2000
0009C4  3               VRAM_layer2    = $F3000
0009C4  3               VRAM_sprinfo   = $F4000
0009C4  3               VRAM_sprdata   = $F5800
0009C4  3               
0009C4  3               VRAM_palette0  = $F1000 + (2*16)*0
0009C4  3               VRAM_palette1  = $F1000 + (2*16)*1
0009C4  3               VRAM_palette2  = $F1000 + (2*16)*2
0009C4  3               VRAM_palette3  = $F1000 + (2*16)*3
0009C4  3               VRAM_palette4  = $F1000 + (2*16)*4
0009C4  3               VRAM_palette5  = $F1000 + (2*16)*5
0009C4  3               VRAM_palette6  = $F1000 + (2*16)*6
0009C4  3               VRAM_palette7  = $F1000 + (2*16)*7
0009C4  3               VRAM_palette8  = $F1000 + (2*16)*8
0009C4  3               VRAM_palette9  = $F1000 + (2*16)*9
0009C4  3               VRAM_palette10 = $F1000 + (2*16)*10
0009C4  3               VRAM_palette11 = $F1000 + (2*16)*11
0009C4  3               VRAM_palette12 = $F1000 + (2*16)*12
0009C4  3               VRAM_palette13 = $F1000 + (2*16)*13
0009C4  3               VRAM_palette14 = $F1000 + (2*16)*14
0009C4  3               VRAM_palette15 = $F1000 + (2*16)*15
0009C4  3               
0009C4  3               VROM_petscii   = $1F000
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ;=================================================
0009C4  3               ;
0009C4  3               ;   Macros
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_SELECT_ADDR
0009C4  3               ;   Select which address channel to configure (VERA_data vs. VERA_data2)
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   addr	0 for VERA_data
0009C4  3               ;					1 for VERA_data2
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_SELECT_ADDR addr
0009C4  3               	lda #addr
0009C4  3               	sta VERA_ctrl
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_SET_ADDR (multiple)
0009C4  3               ;   Set the current address channel's address
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   addr			VRAM address to set to
0009C4  3               ;			[stride = 1]	Address stride/auto-increment
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_SET_ADDR addr, stride
0009C4  3               	.ifnblank stride
0009C4  3               		lda #((^addr) | (stride << 4))
0009C4  3               	.else
0009C4  3               		lda #(^addr) | $10
0009C4  3               	.endif
0009C4  3               
0009C4  3               	sta VERA_addr_bank
0009C4  3               	lda #(>addr)
0009C4  3               	sta VERA_addr_high
0009C4  3               	lda #(<addr)
0009C4  3               	sta VERA_addr_low
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_WRITE (multiple)
0009C4  3               ;   Write values to VERA_data.
0009C4  3               ;	If more than 8 values are needed, consider
0009C4  3               ;	the SYS_STREAM_* family.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   v0 - v7	Values to write
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_WRITE v0, v1, v2, v3, v4, v5, v6, v7
0009C4  3               	.ifblank v0
0009C4  3               		.exitmacro
0009C4  3               	.else
0009C4  3               		lda #v0
0009C4  3               		sta VERA_data
0009C4  3               	.endif
0009C4  3               
0009C4  3               	.if .paramcount > 1
0009C4  3               		VERA_WRITE v1, v2, v3, v4, v5, v6, v7
0009C4  3               	.endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VPEEK
0009C4  3               ;   It's... VPEEK(), but in assembly.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   addr	VRAM address to read from.
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VPEEK addr
0009C4  3               	VERA_SET_ADDR addr
0009C4  3               	lda VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_ENABLE_LAYER
0009C4  3               ;   Enable the specified layer
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   layer	Which layer to enable
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_ENABLE_LAYER layer
0009C4  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
0009C4  3               	lda VERA_data
0009C4  3               	ora #$01
0009C4  3               	sta VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_DISABLE_LAYER
0009C4  3               ;   Disable the specified layer
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   layer	Which layer to enable
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_DISABLE_LAYER layer
0009C4  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
0009C4  3               	lda VERA_data
0009C4  3               	and #$FE
0009C4  3               	sta VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_CONFIGURE_TILE_LAYER
0009C4  3               ;   Apply the given params to a layer.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   layer			Layer (0|1)
0009C4  3               ;			enable			0: disable layer
0009C4  3               ;							1: enable layer
0009C4  3               ;			mode			0: text 1bpp, 16 color f/g
0009C4  3               ;							1: text 1bpp, 256 color f
0009C4  3               ;							2: tile 2bpp
0009C4  3               ;							3: tile 4bpp
0009C4  3               ;							4: tile 8bpp
0009C4  3               ;			w16_tiles		(0|1) enable 16-width tiles?
0009C4  3               ;			h16_tiles		(0|1) enable 16-height tiles?
0009C4  3               ;			mapw, maph		0: 32 tiles/chars
0009C4  3               ;							1: 64 tiles/chars
0009C4  3               ;							2: 128 tiles/chars
0009C4  3               ;							3: 256 tiles/chars
0009C4  3               ;			map_base		Start address of map indices (4-byte align)
0009C4  3               ;			tile_base		Start address of tile indices (4-byte align)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_CONFIGURE_TILE_LAYER layer, enable, mode, w16_tiles, h16_tiles, mapw, maph, map_base, tile_base
0009C4  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
0009C4  3               
0009C4  3               	; Mode
0009C4  3               	lda #((mode << 5) | enable)
0009C4  3               	sta VERA_data
0009C4  3               
0009C4  3               	; Tile and map size
0009C4  3               	lda #((h16_tiles << 5) | (w16_tiles << 4) | (maph << 2) | (mapw))
0009C4  3               	sta VERA_data
0009C4  3               
0009C4  3               .if (map_base & $FFFFFC) <> map_base
0009C4  3               	.error "Map data does not obey alignment rules"
0009C4  3               .endif
0009C4  3               
0009C4  3               .if (tile_base & $FFFFFC) <> tile_base
0009C4  3               	.error "Tile data does not obey alignment rules"
0009C4  3               .endif
0009C4  3               
0009C4  3               	; Map base
0009C4  3               	lda #<(map_base >> 2)
0009C4  3               	sta VERA_data
0009C4  3               	lda #>(map_base >> 2)
0009C4  3               	sta VERA_data
0009C4  3               
0009C4  3               	; Tile base
0009C4  3               	lda #<(tile_base >> 2)
0009C4  3               	sta VERA_data
0009C4  3               	lda #>(tile_base >> 2)
0009C4  3               	sta VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_CONFIGURE_BMP_LAYER
0009C4  3               ;   Apply the given params to a layer.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   layer			Layer (0|1)
0009C4  3               ;			mode			5: bitmap 2bpp
0009C4  3               ;							6: bitmap 4bpp
0009C4  3               ;							7: bitmap 8bpp
0009C4  3               ;			h640			(0|1) enable 640p height?
0009C4  3               ;			palette_offset	Which 16-color palette should it use?
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_CONFIGURE_BMP_LAYER layer, mode, h640, palette_offset
0009C4  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
0009C4  3               
0009C4  3               	; Mode
0009C4  3               	lda #((mode << 5) | 1)
0009C4  3               	sta VERA_data
0009C4  3               
0009C4  3               	; Tile and map size
0009C4  3               	lda #(h640 << 8)
0009C4  3               	sta VERA_data
0009C4  3               
0009C4  3               	; Palette offset
0009C4  3               	lda #((layer << 4) | 7)
0009C4  3               	sta VERA_addr_low
0009C4  3               
0009C4  3               	lda #((palette_offset) >> 4)
0009C4  3               	sta VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_ENABLE_SPRITES
0009C4  3               ;   Enables sprites layer
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_ENABLE_SPRITES
0009C4  3                   VERA_SET_ADDR VRAM_sprinfo
0009C4  3                   lda #1
0009C4  3                   sta VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_DISABLE_SPRITES
0009C4  3               ;   Disables sprites layer
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_DISABLE_SPRITES
0009C4  3                   VERA_SET_ADDR VRAM_sprinfo
0009C4  3                   lda #0
0009C4  3                   sta VERA_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_SET_SPRITE
0009C4  3               ;   Set the current address channel to target
0009C4  3               ;	an indexed sprite_data entry in VRAM_sprdata
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   sprite_index	Sprite index to target
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_SET_SPRITE sprite_index
0009C4  3               	VERA_SET_ADDR (VRAM_sprdata + (sprite_index << 3))
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_CONFIGURE_SPRITE
0009C4  3               ;   Configure sprite data at the current sprite
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   data_addr	Location in VRAM where sprite data exists
0009C4  3               ;			colors			0: 4bpp
0009C4  3               ;							1: 8bpp
0009C4  3               ;			xpos			X-position
0009C4  3               ;			ypos			Y-position
0009C4  3               ;			hflip			toggle horizontal flip
0009C4  3               ;			vflip			toggle verticle flip
0009C4  3               ;			zdepth			Z-depth of sprite
0009C4  3               ;			palette_index	16-color-palette index selection
0009C4  3               ;			width, height	0: 8px
0009C4  3               ;							1: 16px
0009C4  3               ;							2: 32px
0009C4  3               ;							3: 64px
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_CONFIGURE_SPRITE data_addr, colors, xpos, ypos, hflip, vflip, zdepth, palette_index, width, height
0009C4  3               .local DATA_ADDR
0009C4  3               DATA_ADDR=(data_addr >> 5)
0009C4  3               
0009C4  3               .if ((DATA_ADDR << 5) <> data_addr)
0009C4  3               	.error "Sprite data does not obey alignment rules"
0009C4  3               .endif
0009C4  3               
0009C4  3               	VERA_WRITE <DATA_ADDR, >(DATA_ADDR | (colors << 7))
0009C4  3               	VERA_WRITE <(xpos & $0FF), >(xpos & $300), <(ypos & $0FF), >(ypos & $300)
0009C4  3               	VERA_WRITE	((hflip) | (vflip << 1) | (zdepth << 2))
0009C4  3               	VERA_WRITE ((palette_index & $0F) | (width << 4) | (height << 6))
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_SET_PALETTE
0009C4  3               ;   Set the current address channel to target
0009C4  3               ;	an indexed palette  entry in VRAM_palette
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   palette_index		Palette index to target
0009C4  3               ;			[.color_offset = 0]	Which color within the palette to target
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_SET_PALETTE palette_index, color_offset
0009C4  3               	.ifblank color_offset
0009C4  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5))
0009C4  3               	.else
0009C4  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5) + (color_offset << 1))
0009C4  3               	.endif
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_STREAM_OUT
0009C4  3               ;   Stream out a block of data to a location in VRAM
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   src	Source data
0009C4  3               ;			dst	Destination start location
0009C4  3               ;			size	Numbers of bytes to stream out (max 64KiB)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A, X, Y, $FB, $FC
0009C4  3               ;
0009C4  3               .macro VERA_STREAM_OUT src, dst, size
0009C4  3                   VERA_SET_ADDR dst
0009C4  3                   ldy #<(size)
0009C4  3                   ldx #>(size)
0009C4  3                   lda #<src
0009C4  3                   sta $FB
0009C4  3                   lda #>src
0009C4  3                   sta $FC
0009C4  3                   jsr vera_stream_out_data
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_ENABLE_ALL
0009C4  3               ;   Enables all layers and global sprites
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_ENABLE_ALL
0009C4  3                   VERA_SET_ADDR VRAM_layer1, 13
0009C4  3               	VERA_SELECT_ADDR 1
0009C4  3                   VERA_SET_ADDR VRAM_layer1, 13
0009C4  3               
0009C4  3               	; Layer 0
0009C4  3                   lda VERA_data
0009C4  3                   ora #$01
0009C4  3               	sta VERA_data2
0009C4  3               
0009C4  3               	; Layer 1
0009C4  3                   lda VERA_data
0009C4  3                   ora #$01
0009C4  3               	sta VERA_data2
0009C4  3               
0009C4  3               	;Sprites
0009C4  3                   lda VERA_data
0009C4  3                   ora #$01
0009C4  3               	sta VERA_data2
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_DISABLE_ALL
0009C4  3               ;   Enables all layers and global sprites
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_DISABLE_ALL
0009C4  3                   VERA_SET_ADDR VRAM_layer1, 13
0009C4  3               	VERA_SELECT_ADDR 1
0009C4  3                   VERA_SET_ADDR VRAM_layer1, 13
0009C4  3               
0009C4  3               	; Layer 0
0009C4  3                   lda VERA_data
0009C4  3                   and #$FE
0009C4  3               	sta VERA_data2
0009C4  3               
0009C4  3               	; Layer 1
0009C4  3                   lda VERA_data
0009C4  3                   and #$FE
0009C4  3               	sta VERA_data2
0009C4  3               
0009C4  3               	;Sprites
0009C4  3                   lda VERA_data
0009C4  3                   and #$FE
0009C4  3               	sta VERA_data2
0009C4  3               .endmacro
0009C4  3               
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_RESET
0009C4  3               ;   Reset the Vera to its default settings.
0009C4  3               ;	See official documentation for specifics.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_RESET
0009C4  3               	lda #$80
0009C4  3               	sta VERA_ctrl
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VERA_END_IRQ
0009C4  3               ;   Reset the Vera IRQ flag so that it generates interrupts.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VERA_END_IRQ
0009C4  3               	lda #$1
0009C4  3               	sta VERA_irq
0009C4  3               .endmacro
0009C4  3               
0009C4  3               ;=================================================
0009C4  3               ; VIDEO_INIT
0009C4  3               ;   Turn on the video display.
0009C4  3               ;-------------------------------------------------
0009C4  3               ; INPUTS:   (none)
0009C4  3               ;
0009C4  3               ;-------------------------------------------------
0009C4  3               ; MODIFIES: A
0009C4  3               ;
0009C4  3               .macro VIDEO_INIT
0009C4  3               	VERA_SELECT_ADDR 0
0009C4  3               	VERA_SET_ADDR VRAM_composer, 1
0009C4  3               	lda #1
0009C4  3               	sta VERA_data ; VGA output
0009C4  3               .endmacro
0009C4  3               
0009C4  3               .endif ; VERA_INC
0009C4  3               
0009C4  2               
0009C4  2               ;=================================================
0009C4  2               ;=================================================
0009C4  2               ;
0009C4  2               ;   Random number generation
0009C4  2               ;
0009C4  2               ;-------------------------------------------------
0009C4  2               ;
0009C4  2               ; This random number generation routine is based
0009C4  2               ; on a linear feedback shift register, or LFSR.
0009C4  2               ; It's a common technique for generating complex
0009C4  2               ; sequences of values.
0009C4  2               ;
0009C4  2               ; This specific implementation is based on:
0009C4  2               ; https://wiki.nesdev.com/w/index.php/Random_number_generator/Linear_feedback_shift_register_(advanced)
0009C4  2               ;
0009C4  2               
0009C4  2               ;=================================================
0009C4  2               ; sys_rand
0009C4  2               ;   Generate an 8-bit random number.
0009C4  2               ;-------------------------------------------------
0009C4  2               ; INPUTS:   Sys_rand_mem
0009C4  2               ;
0009C4  2               ;-------------------------------------------------
0009C4  2               ; MODIFIES: A, X, Sys_rand_mem
0009C4  2               ;
0009C4  2               sys_rand:
0009C4  2  A2 08            ldx #8
0009C6  2  AD D1 98         lda Sys_rand_mem
0009C9  2  0A           :   asl
0009CA  2  2E D2 98         rol Sys_rand_mem+1
0009CD  2  2E D3 98         rol Sys_rand_mem+2
0009D0  2  90 02            bcc :+
0009D2  2  49 1B            eor #$1B
0009D4  2  CA           :   dex
0009D5  2  D0 F2            bne :--
0009D7  2  8D D1 98         sta Sys_rand_mem
0009DA  2  C9 00            cmp #0
0009DC  2  60               rts
0009DD  2               ;=================================================
0009DD  2               ; sys_wait_one_frame
0009DD  2               ;   Wait for a new frame
0009DD  2               ;-------------------------------------------------
0009DD  2               ; INPUTS:   (none)
0009DD  2               ;
0009DD  2               ;-------------------------------------------------
0009DD  2               ; MODIFIES: A, X, Sys_frame
0009DD  2               ;
0009DD  2               sys_wait_one_frame:
0009DD  2  A9 01            lda #1
0009DF  2  20 E3 09         jsr sys_wait_for_frame
0009E2  2  60               rts
0009E3  2               
0009E3  2               ;=================================================
0009E3  2               ; sys_wait_for_frame
0009E3  2               ;   Wait for a new frame
0009E3  2               ;-------------------------------------------------
0009E3  2               ; INPUTS:   A   number of frames to wait
0009E3  2               ;
0009E3  2               ;-------------------------------------------------
0009E3  2               ; MODIFIES: A, X, Sys_frame
0009E3  2               ;
0009E3  2               sys_wait_for_frame:
0009E3  2  18               clc
0009E4  2  6D D4 98         adc Sys_frame
0009E7  2  AA               tax
0009E8  2               
0009E8  2  A9 FA 8D 14      SYS_SET_IRQ sys_inc_frame
0009EC  2  03 A9 09 8D  
0009F0  2  15 03        
0009F2  2  58               cli
0009F3  2               
0009F3  2                   ; Tight loop until next frame
0009F3  2  EC D4 98     :   cpx Sys_frame
0009F6  2  D0 FB            bne :-
0009F8  2               
0009F8  2  78               sei
0009F9  2  60               rts
0009FA  2               
0009FA  2               ;=================================================
0009FA  2               ; sys_inc_frame
0009FA  2               ;   Increment a value when a new frame arrives
0009FA  2               ;-------------------------------------------------
0009FA  2               ; INPUTS:   (none)
0009FA  2               ;
0009FA  2               ;-------------------------------------------------
0009FA  2               ; MODIFIES: New_frame
0009FA  2               ;
0009FA  2               sys_inc_frame:
0009FA  2  EE D4 98         inc Sys_frame
0009FD  2  A9 01 8D 27      VERA_END_IRQ
000A01  2  9F           
000A02  2  68 A8 68 AA      SYS_END_IRQ
000A06  2  68 40        
000A08  2               
000A08  2               .endif ; SYSTEM_ASM
000A08  2               
000A08  1               .include "graphics.asm"
000A08  2               .ifndef GRAPHICS_ASM
000A08  2               GRAPHICS_ASM=1
000A08  2               
000A08  2               .include "vera.inc"
000A08  3               
000A08  3               .ifndef VERA_INC
000A08  3               VERA_INC=1
000A08  3               
000A08  3               .include "system.inc"
000A08  3               
000A08  3               ;=================================================
000A08  3               ;=================================================
000A08  3               ;
000A08  3               ;   Memory-mapped registers
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               
000A08  3               .ifdef MACHINE_C64
000A08  3               	VERA_base = $df00
000A08  3               .else
000A08  3               	VERA_base = $9f20
000A08  3               .endif
000A08  3               
000A08  3               VERA_addr_low   = VERA_base+0
000A08  3               VERA_addr_high  = VERA_base+1
000A08  3               VERA_addr_bank  = VERA_base+2
000A08  3               VERA_data       = VERA_base+3
000A08  3               VERA_data2      = VERA_base+4
000A08  3               VERA_ctrl       = VERA_base+5
000A08  3               VERA_irq_ctrl   = VERA_base+6
000A08  3               VERA_irq        = VERA_base+7
000A08  3               
000A08  3               VRAM_composer  = $F0000
000A08  3               VRAM_palette   = $F1000
000A08  3               VRAM_layer1    = $F2000
000A08  3               VRAM_layer2    = $F3000
000A08  3               VRAM_sprinfo   = $F4000
000A08  3               VRAM_sprdata   = $F5800
000A08  3               
000A08  3               VRAM_palette0  = $F1000 + (2*16)*0
000A08  3               VRAM_palette1  = $F1000 + (2*16)*1
000A08  3               VRAM_palette2  = $F1000 + (2*16)*2
000A08  3               VRAM_palette3  = $F1000 + (2*16)*3
000A08  3               VRAM_palette4  = $F1000 + (2*16)*4
000A08  3               VRAM_palette5  = $F1000 + (2*16)*5
000A08  3               VRAM_palette6  = $F1000 + (2*16)*6
000A08  3               VRAM_palette7  = $F1000 + (2*16)*7
000A08  3               VRAM_palette8  = $F1000 + (2*16)*8
000A08  3               VRAM_palette9  = $F1000 + (2*16)*9
000A08  3               VRAM_palette10 = $F1000 + (2*16)*10
000A08  3               VRAM_palette11 = $F1000 + (2*16)*11
000A08  3               VRAM_palette12 = $F1000 + (2*16)*12
000A08  3               VRAM_palette13 = $F1000 + (2*16)*13
000A08  3               VRAM_palette14 = $F1000 + (2*16)*14
000A08  3               VRAM_palette15 = $F1000 + (2*16)*15
000A08  3               
000A08  3               VROM_petscii   = $1F000
000A08  3               
000A08  3               ;=================================================
000A08  3               ;=================================================
000A08  3               ;
000A08  3               ;   Macros
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_SELECT_ADDR
000A08  3               ;   Select which address channel to configure (VERA_data vs. VERA_data2)
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   addr	0 for VERA_data
000A08  3               ;					1 for VERA_data2
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_SELECT_ADDR addr
000A08  3               	lda #addr
000A08  3               	sta VERA_ctrl
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_SET_ADDR (multiple)
000A08  3               ;   Set the current address channel's address
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   addr			VRAM address to set to
000A08  3               ;			[stride = 1]	Address stride/auto-increment
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_SET_ADDR addr, stride
000A08  3               	.ifnblank stride
000A08  3               		lda #((^addr) | (stride << 4))
000A08  3               	.else
000A08  3               		lda #(^addr) | $10
000A08  3               	.endif
000A08  3               
000A08  3               	sta VERA_addr_bank
000A08  3               	lda #(>addr)
000A08  3               	sta VERA_addr_high
000A08  3               	lda #(<addr)
000A08  3               	sta VERA_addr_low
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_WRITE (multiple)
000A08  3               ;   Write values to VERA_data.
000A08  3               ;	If more than 8 values are needed, consider
000A08  3               ;	the SYS_STREAM_* family.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   v0 - v7	Values to write
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_WRITE v0, v1, v2, v3, v4, v5, v6, v7
000A08  3               	.ifblank v0
000A08  3               		.exitmacro
000A08  3               	.else
000A08  3               		lda #v0
000A08  3               		sta VERA_data
000A08  3               	.endif
000A08  3               
000A08  3               	.if .paramcount > 1
000A08  3               		VERA_WRITE v1, v2, v3, v4, v5, v6, v7
000A08  3               	.endif
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VPEEK
000A08  3               ;   It's... VPEEK(), but in assembly.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   addr	VRAM address to read from.
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VPEEK addr
000A08  3               	VERA_SET_ADDR addr
000A08  3               	lda VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_ENABLE_LAYER
000A08  3               ;   Enable the specified layer
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   layer	Which layer to enable
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_ENABLE_LAYER layer
000A08  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000A08  3               	lda VERA_data
000A08  3               	ora #$01
000A08  3               	sta VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_DISABLE_LAYER
000A08  3               ;   Disable the specified layer
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   layer	Which layer to enable
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_DISABLE_LAYER layer
000A08  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000A08  3               	lda VERA_data
000A08  3               	and #$FE
000A08  3               	sta VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_CONFIGURE_TILE_LAYER
000A08  3               ;   Apply the given params to a layer.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   layer			Layer (0|1)
000A08  3               ;			enable			0: disable layer
000A08  3               ;							1: enable layer
000A08  3               ;			mode			0: text 1bpp, 16 color f/g
000A08  3               ;							1: text 1bpp, 256 color f
000A08  3               ;							2: tile 2bpp
000A08  3               ;							3: tile 4bpp
000A08  3               ;							4: tile 8bpp
000A08  3               ;			w16_tiles		(0|1) enable 16-width tiles?
000A08  3               ;			h16_tiles		(0|1) enable 16-height tiles?
000A08  3               ;			mapw, maph		0: 32 tiles/chars
000A08  3               ;							1: 64 tiles/chars
000A08  3               ;							2: 128 tiles/chars
000A08  3               ;							3: 256 tiles/chars
000A08  3               ;			map_base		Start address of map indices (4-byte align)
000A08  3               ;			tile_base		Start address of tile indices (4-byte align)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_CONFIGURE_TILE_LAYER layer, enable, mode, w16_tiles, h16_tiles, mapw, maph, map_base, tile_base
000A08  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000A08  3               
000A08  3               	; Mode
000A08  3               	lda #((mode << 5) | enable)
000A08  3               	sta VERA_data
000A08  3               
000A08  3               	; Tile and map size
000A08  3               	lda #((h16_tiles << 5) | (w16_tiles << 4) | (maph << 2) | (mapw))
000A08  3               	sta VERA_data
000A08  3               
000A08  3               .if (map_base & $FFFFFC) <> map_base
000A08  3               	.error "Map data does not obey alignment rules"
000A08  3               .endif
000A08  3               
000A08  3               .if (tile_base & $FFFFFC) <> tile_base
000A08  3               	.error "Tile data does not obey alignment rules"
000A08  3               .endif
000A08  3               
000A08  3               	; Map base
000A08  3               	lda #<(map_base >> 2)
000A08  3               	sta VERA_data
000A08  3               	lda #>(map_base >> 2)
000A08  3               	sta VERA_data
000A08  3               
000A08  3               	; Tile base
000A08  3               	lda #<(tile_base >> 2)
000A08  3               	sta VERA_data
000A08  3               	lda #>(tile_base >> 2)
000A08  3               	sta VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_CONFIGURE_BMP_LAYER
000A08  3               ;   Apply the given params to a layer.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   layer			Layer (0|1)
000A08  3               ;			mode			5: bitmap 2bpp
000A08  3               ;							6: bitmap 4bpp
000A08  3               ;							7: bitmap 8bpp
000A08  3               ;			h640			(0|1) enable 640p height?
000A08  3               ;			palette_offset	Which 16-color palette should it use?
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_CONFIGURE_BMP_LAYER layer, mode, h640, palette_offset
000A08  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000A08  3               
000A08  3               	; Mode
000A08  3               	lda #((mode << 5) | 1)
000A08  3               	sta VERA_data
000A08  3               
000A08  3               	; Tile and map size
000A08  3               	lda #(h640 << 8)
000A08  3               	sta VERA_data
000A08  3               
000A08  3               	; Palette offset
000A08  3               	lda #((layer << 4) | 7)
000A08  3               	sta VERA_addr_low
000A08  3               
000A08  3               	lda #((palette_offset) >> 4)
000A08  3               	sta VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_ENABLE_SPRITES
000A08  3               ;   Enables sprites layer
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_ENABLE_SPRITES
000A08  3                   VERA_SET_ADDR VRAM_sprinfo
000A08  3                   lda #1
000A08  3                   sta VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_DISABLE_SPRITES
000A08  3               ;   Disables sprites layer
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_DISABLE_SPRITES
000A08  3                   VERA_SET_ADDR VRAM_sprinfo
000A08  3                   lda #0
000A08  3                   sta VERA_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_SET_SPRITE
000A08  3               ;   Set the current address channel to target
000A08  3               ;	an indexed sprite_data entry in VRAM_sprdata
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   sprite_index	Sprite index to target
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_SET_SPRITE sprite_index
000A08  3               	VERA_SET_ADDR (VRAM_sprdata + (sprite_index << 3))
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_CONFIGURE_SPRITE
000A08  3               ;   Configure sprite data at the current sprite
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   data_addr	Location in VRAM where sprite data exists
000A08  3               ;			colors			0: 4bpp
000A08  3               ;							1: 8bpp
000A08  3               ;			xpos			X-position
000A08  3               ;			ypos			Y-position
000A08  3               ;			hflip			toggle horizontal flip
000A08  3               ;			vflip			toggle verticle flip
000A08  3               ;			zdepth			Z-depth of sprite
000A08  3               ;			palette_index	16-color-palette index selection
000A08  3               ;			width, height	0: 8px
000A08  3               ;							1: 16px
000A08  3               ;							2: 32px
000A08  3               ;							3: 64px
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_CONFIGURE_SPRITE data_addr, colors, xpos, ypos, hflip, vflip, zdepth, palette_index, width, height
000A08  3               .local DATA_ADDR
000A08  3               DATA_ADDR=(data_addr >> 5)
000A08  3               
000A08  3               .if ((DATA_ADDR << 5) <> data_addr)
000A08  3               	.error "Sprite data does not obey alignment rules"
000A08  3               .endif
000A08  3               
000A08  3               	VERA_WRITE <DATA_ADDR, >(DATA_ADDR | (colors << 7))
000A08  3               	VERA_WRITE <(xpos & $0FF), >(xpos & $300), <(ypos & $0FF), >(ypos & $300)
000A08  3               	VERA_WRITE	((hflip) | (vflip << 1) | (zdepth << 2))
000A08  3               	VERA_WRITE ((palette_index & $0F) | (width << 4) | (height << 6))
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_SET_PALETTE
000A08  3               ;   Set the current address channel to target
000A08  3               ;	an indexed palette  entry in VRAM_palette
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   palette_index		Palette index to target
000A08  3               ;			[.color_offset = 0]	Which color within the palette to target
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_SET_PALETTE palette_index, color_offset
000A08  3               	.ifblank color_offset
000A08  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5))
000A08  3               	.else
000A08  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5) + (color_offset << 1))
000A08  3               	.endif
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_STREAM_OUT
000A08  3               ;   Stream out a block of data to a location in VRAM
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   src	Source data
000A08  3               ;			dst	Destination start location
000A08  3               ;			size	Numbers of bytes to stream out (max 64KiB)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A, X, Y, $FB, $FC
000A08  3               ;
000A08  3               .macro VERA_STREAM_OUT src, dst, size
000A08  3                   VERA_SET_ADDR dst
000A08  3                   ldy #<(size)
000A08  3                   ldx #>(size)
000A08  3                   lda #<src
000A08  3                   sta $FB
000A08  3                   lda #>src
000A08  3                   sta $FC
000A08  3                   jsr vera_stream_out_data
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_ENABLE_ALL
000A08  3               ;   Enables all layers and global sprites
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_ENABLE_ALL
000A08  3                   VERA_SET_ADDR VRAM_layer1, 13
000A08  3               	VERA_SELECT_ADDR 1
000A08  3                   VERA_SET_ADDR VRAM_layer1, 13
000A08  3               
000A08  3               	; Layer 0
000A08  3                   lda VERA_data
000A08  3                   ora #$01
000A08  3               	sta VERA_data2
000A08  3               
000A08  3               	; Layer 1
000A08  3                   lda VERA_data
000A08  3                   ora #$01
000A08  3               	sta VERA_data2
000A08  3               
000A08  3               	;Sprites
000A08  3                   lda VERA_data
000A08  3                   ora #$01
000A08  3               	sta VERA_data2
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_DISABLE_ALL
000A08  3               ;   Enables all layers and global sprites
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_DISABLE_ALL
000A08  3                   VERA_SET_ADDR VRAM_layer1, 13
000A08  3               	VERA_SELECT_ADDR 1
000A08  3                   VERA_SET_ADDR VRAM_layer1, 13
000A08  3               
000A08  3               	; Layer 0
000A08  3                   lda VERA_data
000A08  3                   and #$FE
000A08  3               	sta VERA_data2
000A08  3               
000A08  3               	; Layer 1
000A08  3                   lda VERA_data
000A08  3                   and #$FE
000A08  3               	sta VERA_data2
000A08  3               
000A08  3               	;Sprites
000A08  3                   lda VERA_data
000A08  3                   and #$FE
000A08  3               	sta VERA_data2
000A08  3               .endmacro
000A08  3               
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_RESET
000A08  3               ;   Reset the Vera to its default settings.
000A08  3               ;	See official documentation for specifics.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_RESET
000A08  3               	lda #$80
000A08  3               	sta VERA_ctrl
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VERA_END_IRQ
000A08  3               ;   Reset the Vera IRQ flag so that it generates interrupts.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VERA_END_IRQ
000A08  3               	lda #$1
000A08  3               	sta VERA_irq
000A08  3               .endmacro
000A08  3               
000A08  3               ;=================================================
000A08  3               ; VIDEO_INIT
000A08  3               ;   Turn on the video display.
000A08  3               ;-------------------------------------------------
000A08  3               ; INPUTS:   (none)
000A08  3               ;
000A08  3               ;-------------------------------------------------
000A08  3               ; MODIFIES: A
000A08  3               ;
000A08  3               .macro VIDEO_INIT
000A08  3               	VERA_SELECT_ADDR 0
000A08  3               	VERA_SET_ADDR VRAM_composer, 1
000A08  3               	lda #1
000A08  3               	sta VERA_data ; VGA output
000A08  3               .endmacro
000A08  3               
000A08  3               .endif ; VERA_INC
000A08  3               
000A08  2               
000A08  2               ;=================================================
000A08  2               ;=================================================
000A08  2               ;
000A08  2               ;   General-purpose graphics routines
000A08  2               ;
000A08  2               ;-------------------------------------------------
000A08  2               
000A08  2               ;=================================================
000A08  2               ; graphics_fade_out
000A08  2               ;   Use palette decrementing to fade out the screen to black.
000A08  2               ;-------------------------------------------------
000A08  2               ; INPUTS:   (none)
000A08  2               ;
000A08  2               ;-------------------------------------------------
000A08  2               ; MODIFIES: A, X, Y
000A08  2               ;
000A08  2               graphics_fade_out:
000A08  2                   ; This is an optimistic flag: have we cleared the entire palette?
000A08  2                   ; We'll falsify if not.
000A08  2  A9 01            lda #1
000A0A  2  8D CD 98         sta Gfx_all_palettes_cleared
000A0D  2               
000A0D  2  A9 00 8D 25      VERA_SELECT_ADDR 0
000A11  2  9F           
000A12  2  A9 1F 8D 22      VERA_SET_PALETTE 0
000A16  2  9F A9 10 8D  
000A1A  2  21 9F A9 00  
000A21  2  A9 01 8D 25      VERA_SELECT_ADDR 1
000A25  2  9F           
000A26  2  A9 1F 8D 22      VERA_SET_PALETTE 0
000A2A  2  9F A9 10 8D  
000A2E  2  21 9F A9 00  
000A35  2               
000A35  2  A0 00            ldy #0 ; 256 colors in the palette
000A37  2               
000A37  2               @decrement_palette_entry:
000A37  2  AD 23 9F         lda VERA_data
000A3A  2                   ; Don't need to decrement if already #0 (black)
000A3A  2  C9 00            cmp #0
000A3C  2  F0 09            beq @store_gb
000A3E  2               
000A3E  2                   ; The first byte is %ggggbbbb, so we need to decrement
000A3E  2                   ; each half if not 0. Instead of complex assembly to do that, I'm just
000A3E  2                   ; going to precompute to a table and do a lookup of the next value.
000A3E  2                   ; And since I did it that way for the first byte, do it the same
000A3E  2                   ; way for the second as well since that answer is good for both.
000A3E  2  AA               tax
000A3F  2               
000A3F  2  A9 00            lda #0
000A41  2  8D CD 98         sta Gfx_all_palettes_cleared
000A44  2               
000A44  2  BD F1 0A         lda Gfx_palette_decrement_table, X
000A47  2               
000A47  2               @store_gb:
000A47  2  8D 24 9F        sta VERA_data2
000A4A  2               
000A4A  2  AD 23 9F         lda VERA_data
000A4D  2               
000A4D  2                   ; Still don't need to decrement 0.
000A4D  2  C9 00            cmp #0
000A4F  2  F0 09            beq @store_r
000A51  2               
000A51  2  AA               tax
000A52  2               
000A52  2  A9 00            lda #0
000A54  2  8D CD 98         sta Gfx_all_palettes_cleared
000A57  2               
000A57  2  BD F1 0A         lda Gfx_palette_decrement_table, X
000A5A  2               
000A5A  2               @store_r:
000A5A  2  8D 24 9F         sta VERA_data2
000A5D  2               
000A5D  2  88               dey
000A5E  2  D0 D7            bne @decrement_palette_entry
000A60  2               
000A60  2  20 DD 09         jsr sys_wait_one_frame
000A63  2               
000A63  2  AD CD 98         lda Gfx_all_palettes_cleared
000A66  2  C9 00            cmp #0
000A68  2  F0 9E            beq graphics_fade_out
000A6A  2               
000A6A  2  60               rts
000A6B  2               
000A6B  2               
000A6B  2               ;=================================================
000A6B  2               ; graphics_fade_in
000A6B  2               ;   Use palette incmenting to fade in the screen from black.
000A6B  2               ;-------------------------------------------------
000A6B  2               ; INPUTS:   $FB-$FC Address of intended palette
000A6B  2               ;           $FD     Number of colors in palette (0 for all 256)
000A6B  2               ;
000A6B  2               ;-------------------------------------------------
000A6B  2               ; MODIFIES: A, X, Y, $FB-$FF
000A6B  2               ;
000A6B  2               graphics_fade_in:
000A6B  2  A5 FB            lda $FB
000A6D  2  85 FE            sta $FE
000A6F  2  A5 FC            lda $FC
000A71  2  85 FF            sta $FF
000A73  2                   ; This is an optimistic flag: have we cleared the entire palette?
000A73  2                   ; We'll falsify if not.
000A73  2  A9 01            lda #1
000A75  2  8D CD 98         sta Gfx_all_palettes_cleared
000A78  2               
000A78  2  A9 00 8D 25      VERA_SELECT_ADDR 0
000A7C  2  9F           
000A7D  2  A9 1F 8D 22      VERA_SET_PALETTE 0
000A81  2  9F A9 10 8D  
000A85  2  21 9F A9 00  
000A8C  2  A9 01 8D 25      VERA_SELECT_ADDR 1
000A90  2  9F           
000A91  2  A9 1F 8D 22      VERA_SET_PALETTE 0
000A95  2  9F A9 10 8D  
000A99  2  21 9F A9 00  
000AA0  2               
000AA0  2  A0 00            ldy #0 ; 256 colors in palette
000AA2  2               
000AA2  2               @increment_palette_entry:
000AA2  2  AD 23 9F         lda VERA_data
000AA5  2                   ; Don't need to increment if already at target value
000AA5  2  D1 FE            cmp ($FE), Y
000AA7  2  F0 1A            beq @store_gb
000AA9  2               
000AA9  2  AA               tax
000AAA  2               
000AAA  2  A9 00            lda #0
000AAC  2  8D CD 98         sta Gfx_all_palettes_cleared
000AAF  2               
000AAF  2                   ; The first byte is %ggggbbbb, which means we have to increment these separately.
000AAF  2                   ; We're going to xor with the the intended color. This gives us some bits like %aaaabbbb
000AAF  2                   ; where any 'b' bits set mean we increment the bottom half, then any 'a' bits set mean we
000AAF  2                   ; increment the top half.
000AAF  2                   ;   --- I'm a little proud of realizing how much branching an XOR saves me, because I'm
000AAF  2                   ;       a hack and I was literally staring at C++ code that did this:
000AAF  2                   ;
000AAF  2                   ;       unsigned short increment(unsigned short color, unsigned short target) {
000AAF  2                   ;           color = ((color & 0xF0) < (target & 0xF0)) ? color + 0x10 : color;
000AAF  2                   ;           color = ((color & 0x0F) < (target & 0x0F)) ? color + 0x01 : color;
000AAF  2                   ;           return color;
000AAF  2                   ;       }
000AAF  2                   ;
000AAF  2                   ;       Yeah. What a waste of electricity compared to:
000AAF  2                   ;
000AAF  2                   ;       unsigned short increment(unsigned short color, unsigned short target) {
000AAF  2                   ;           unsigned short bit_diff = color ^ target
000AAF  2                   ;           if(bit_diff >= 0x10) color += 0x10;
000AAF  2                   ;           if(bit_diff & 0x0F) color += 0x01;
000AAF  2                   ;       }
000AAF  2               
000AAF  2  8A               txa
000AB0  2  51 FE            eor ($FE), Y
000AB2  2  C9 10            cmp #$10
000AB4  2  90 05            bcc @low_nibble
000AB6  2  8A               txa
000AB7  2  18               clc
000AB8  2  69 10            adc #$10
000ABA  2  AA               tax
000ABB  2               @low_nibble:
000ABB  2  51 FE            eor ($FE), Y
000ABD  2  29 0F            and #$0F
000ABF  2  F0 01            beq @b0
000AC1  2  E8               inx
000AC2  2               @b0:
000AC2  2  8A               txa
000AC3  2               
000AC3  2               @store_gb:
000AC3  2  8D 24 9F         sta VERA_data2
000AC6  2               
000AC6  2                   ; Y holds the number of colors we've copied, so increment our starting address here instead.
000AC6  2                   ; we'll still increment Y at the bottom.
000AC6  2  E6 FE            inc $FE
000AC8  2  D0 02            bne @b1
000ACA  2  E6 FF            inc $FF
000ACC  2               
000ACC  2  AD 23 9F     @b1:   lda VERA_data
000ACF  2                   ; Don't need to increment if already at target value
000ACF  2  D1 FE            cmp ($FE), Y
000AD1  2  F0 08            beq @store_r
000AD3  2               
000AD3  2  AA               tax
000AD4  2               
000AD4  2  A9 00            lda #0
000AD6  2  8D CD 98         sta Gfx_all_palettes_cleared
000AD9  2               
000AD9  2                   ; The second byte is %0000rrrr, which means we can get away with just an increment
000AD9  2  E8               inx
000ADA  2  8A               txa
000ADB  2               @store_r:
000ADB  2  8D 24 9F         sta VERA_data2
000ADE  2               
000ADE  2  C8               iny
000ADF  2  C4 FD            cpy $FD
000AE1  2  D0 BF            bne @increment_palette_entry
000AE3  2               
000AE3  2  20 DD 09         jsr sys_wait_one_frame
000AE6  2               
000AE6  2               __gfx__graphics_fade_in_all_palettes_cleared:
000AE6  2  AD CD 98         lda Gfx_all_palettes_cleared
000AE9  2  C9 01            cmp #1
000AEB  2  F0 03            beq __gfx__graphics_fade_in_return
000AED  2  4C 6B 0A         jmp graphics_fade_in
000AF0  2               
000AF0  2               __gfx__graphics_fade_in_return:
000AF0  2  60               rts
000AF1  2               
000AF1  2               ;=================================================
000AF1  2               ;=================================================
000AF1  2               ;
000AF1  2               ;   Tables and constants
000AF1  2               ;
000AF1  2               ;-------------------------------------------------
000AF1  2               
000AF1  2               Gfx_palette_decrement_table:
000AF1  2                   ;     $X0, $X1, $X2, $X3, $X4, $X5, $X6, $X7, $X8, $X9, $XA, $XB, $XC, $XD, $XE, $XF
000AF1  2  00 00 01 02      .byte $00, $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E    ; $0X
000AF5  2  03 04 05 06  
000AF9  2  07 08 09 0A  
000B01  2  00 00 01 02      .byte $00, $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E    ; $1X
000B05  2  03 04 05 06  
000B09  2  07 08 09 0A  
000B11  2  10 10 11 12      .byte $10, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $1A, $1B, $1C, $1D, $1E    ; $2X
000B15  2  13 14 15 16  
000B19  2  17 18 19 1A  
000B21  2  20 20 21 22      .byte $20, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $2A, $2B, $2C, $2D, $2E    ; $3X
000B25  2  23 24 25 26  
000B29  2  27 28 29 2A  
000B31  2  30 30 31 32      .byte $30, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $3A, $3B, $3C, $3D, $3E    ; $4X
000B35  2  33 34 35 36  
000B39  2  37 38 39 3A  
000B41  2  40 40 41 42      .byte $40, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $4A, $4B, $4C, $4D, $4E    ; $5X
000B45  2  43 44 45 46  
000B49  2  47 48 49 4A  
000B51  2  50 50 51 52      .byte $50, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $5A, $5B, $5C, $5D, $5E    ; $6X
000B55  2  53 54 55 56  
000B59  2  57 58 59 5A  
000B61  2  60 60 61 62      .byte $60, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $6A, $6B, $6C, $6D, $6E    ; $7X
000B65  2  63 64 65 66  
000B69  2  67 68 69 6A  
000B71  2  70 70 71 72      .byte $70, $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $7A, $7B, $7C, $7D, $7E    ; $8X
000B75  2  73 74 75 76  
000B79  2  77 78 79 7A  
000B81  2  80 80 81 82      .byte $80, $80, $81, $82, $83, $84, $85, $86, $87, $88, $89, $8A, $8B, $8C, $8D, $8E    ; $9X
000B85  2  83 84 85 86  
000B89  2  87 88 89 8A  
000B91  2  90 90 91 92      .byte $90, $90, $91, $92, $93, $94, $95, $96, $97, $98, $99, $9A, $9B, $9C, $9D, $9E    ; $AX
000B95  2  93 94 95 96  
000B99  2  97 98 99 9A  
000BA1  2  A0 A0 A1 A2      .byte $A0, $A0, $A1, $A2, $A3, $A4, $A5, $A6, $A7, $A8, $A9, $AA, $AB, $AC, $AD, $AE    ; $BX
000BA5  2  A3 A4 A5 A6  
000BA9  2  A7 A8 A9 AA  
000BB1  2  B0 B0 B1 B2      .byte $B0, $B0, $B1, $B2, $B3, $B4, $B5, $B6, $B7, $B8, $B9, $BA, $BB, $BC, $BD, $BE    ; $CX
000BB5  2  B3 B4 B5 B6  
000BB9  2  B7 B8 B9 BA  
000BC1  2  C0 C0 C1 C2      .byte $C0, $C0, $C1, $C2, $C3, $C4, $C5, $C6, $C7, $C8, $C9, $CA, $CB, $CC, $CD, $CE    ; $DX
000BC5  2  C3 C4 C5 C6  
000BC9  2  C7 C8 C9 CA  
000BD1  2  D0 D0 D1 D2      .byte $D0, $D0, $D1, $D2, $D3, $D4, $D5, $D6, $D7, $D8, $D9, $DA, $DB, $DC, $DD, $DE    ; $EX
000BD5  2  D3 D4 D5 D6  
000BD9  2  D7 D8 D9 DA  
000BE1  2  E0 E0 E1 E2      .byte $E0, $E0, $E1, $E2, $E3, $E4, $E5, $E6, $E7, $E8, $E9, $EA, $EB, $EC, $ED, $EE    ; $FX
000BE5  2  E3 E4 E5 E6  
000BE9  2  E7 E8 E9 EA  
000BF1  2               
000BF1  2               .endif ; GRAPHICS_ASM
000BF1  2               
000BF1  1               .include "splash.asm"
000BF1  2               .ifndef SPLASH_ASM
000BF1  2               SPLASH_ASM=1
000BF1  2               
000BF1  2               .include "vera.inc"
000BF1  3               
000BF1  3               .ifndef VERA_INC
000BF1  3               VERA_INC=1
000BF1  3               
000BF1  3               .include "system.inc"
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ;=================================================
000BF1  3               ;
000BF1  3               ;   Memory-mapped registers
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               
000BF1  3               .ifdef MACHINE_C64
000BF1  3               	VERA_base = $df00
000BF1  3               .else
000BF1  3               	VERA_base = $9f20
000BF1  3               .endif
000BF1  3               
000BF1  3               VERA_addr_low   = VERA_base+0
000BF1  3               VERA_addr_high  = VERA_base+1
000BF1  3               VERA_addr_bank  = VERA_base+2
000BF1  3               VERA_data       = VERA_base+3
000BF1  3               VERA_data2      = VERA_base+4
000BF1  3               VERA_ctrl       = VERA_base+5
000BF1  3               VERA_irq_ctrl   = VERA_base+6
000BF1  3               VERA_irq        = VERA_base+7
000BF1  3               
000BF1  3               VRAM_composer  = $F0000
000BF1  3               VRAM_palette   = $F1000
000BF1  3               VRAM_layer1    = $F2000
000BF1  3               VRAM_layer2    = $F3000
000BF1  3               VRAM_sprinfo   = $F4000
000BF1  3               VRAM_sprdata   = $F5800
000BF1  3               
000BF1  3               VRAM_palette0  = $F1000 + (2*16)*0
000BF1  3               VRAM_palette1  = $F1000 + (2*16)*1
000BF1  3               VRAM_palette2  = $F1000 + (2*16)*2
000BF1  3               VRAM_palette3  = $F1000 + (2*16)*3
000BF1  3               VRAM_palette4  = $F1000 + (2*16)*4
000BF1  3               VRAM_palette5  = $F1000 + (2*16)*5
000BF1  3               VRAM_palette6  = $F1000 + (2*16)*6
000BF1  3               VRAM_palette7  = $F1000 + (2*16)*7
000BF1  3               VRAM_palette8  = $F1000 + (2*16)*8
000BF1  3               VRAM_palette9  = $F1000 + (2*16)*9
000BF1  3               VRAM_palette10 = $F1000 + (2*16)*10
000BF1  3               VRAM_palette11 = $F1000 + (2*16)*11
000BF1  3               VRAM_palette12 = $F1000 + (2*16)*12
000BF1  3               VRAM_palette13 = $F1000 + (2*16)*13
000BF1  3               VRAM_palette14 = $F1000 + (2*16)*14
000BF1  3               VRAM_palette15 = $F1000 + (2*16)*15
000BF1  3               
000BF1  3               VROM_petscii   = $1F000
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ;=================================================
000BF1  3               ;
000BF1  3               ;   Macros
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_SELECT_ADDR
000BF1  3               ;   Select which address channel to configure (VERA_data vs. VERA_data2)
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   addr	0 for VERA_data
000BF1  3               ;					1 for VERA_data2
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_SELECT_ADDR addr
000BF1  3               	lda #addr
000BF1  3               	sta VERA_ctrl
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_SET_ADDR (multiple)
000BF1  3               ;   Set the current address channel's address
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   addr			VRAM address to set to
000BF1  3               ;			[stride = 1]	Address stride/auto-increment
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_SET_ADDR addr, stride
000BF1  3               	.ifnblank stride
000BF1  3               		lda #((^addr) | (stride << 4))
000BF1  3               	.else
000BF1  3               		lda #(^addr) | $10
000BF1  3               	.endif
000BF1  3               
000BF1  3               	sta VERA_addr_bank
000BF1  3               	lda #(>addr)
000BF1  3               	sta VERA_addr_high
000BF1  3               	lda #(<addr)
000BF1  3               	sta VERA_addr_low
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_WRITE (multiple)
000BF1  3               ;   Write values to VERA_data.
000BF1  3               ;	If more than 8 values are needed, consider
000BF1  3               ;	the SYS_STREAM_* family.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   v0 - v7	Values to write
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_WRITE v0, v1, v2, v3, v4, v5, v6, v7
000BF1  3               	.ifblank v0
000BF1  3               		.exitmacro
000BF1  3               	.else
000BF1  3               		lda #v0
000BF1  3               		sta VERA_data
000BF1  3               	.endif
000BF1  3               
000BF1  3               	.if .paramcount > 1
000BF1  3               		VERA_WRITE v1, v2, v3, v4, v5, v6, v7
000BF1  3               	.endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VPEEK
000BF1  3               ;   It's... VPEEK(), but in assembly.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   addr	VRAM address to read from.
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VPEEK addr
000BF1  3               	VERA_SET_ADDR addr
000BF1  3               	lda VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_ENABLE_LAYER
000BF1  3               ;   Enable the specified layer
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   layer	Which layer to enable
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_ENABLE_LAYER layer
000BF1  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000BF1  3               	lda VERA_data
000BF1  3               	ora #$01
000BF1  3               	sta VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_DISABLE_LAYER
000BF1  3               ;   Disable the specified layer
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   layer	Which layer to enable
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_DISABLE_LAYER layer
000BF1  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000BF1  3               	lda VERA_data
000BF1  3               	and #$FE
000BF1  3               	sta VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_CONFIGURE_TILE_LAYER
000BF1  3               ;   Apply the given params to a layer.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   layer			Layer (0|1)
000BF1  3               ;			enable			0: disable layer
000BF1  3               ;							1: enable layer
000BF1  3               ;			mode			0: text 1bpp, 16 color f/g
000BF1  3               ;							1: text 1bpp, 256 color f
000BF1  3               ;							2: tile 2bpp
000BF1  3               ;							3: tile 4bpp
000BF1  3               ;							4: tile 8bpp
000BF1  3               ;			w16_tiles		(0|1) enable 16-width tiles?
000BF1  3               ;			h16_tiles		(0|1) enable 16-height tiles?
000BF1  3               ;			mapw, maph		0: 32 tiles/chars
000BF1  3               ;							1: 64 tiles/chars
000BF1  3               ;							2: 128 tiles/chars
000BF1  3               ;							3: 256 tiles/chars
000BF1  3               ;			map_base		Start address of map indices (4-byte align)
000BF1  3               ;			tile_base		Start address of tile indices (4-byte align)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_CONFIGURE_TILE_LAYER layer, enable, mode, w16_tiles, h16_tiles, mapw, maph, map_base, tile_base
000BF1  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000BF1  3               
000BF1  3               	; Mode
000BF1  3               	lda #((mode << 5) | enable)
000BF1  3               	sta VERA_data
000BF1  3               
000BF1  3               	; Tile and map size
000BF1  3               	lda #((h16_tiles << 5) | (w16_tiles << 4) | (maph << 2) | (mapw))
000BF1  3               	sta VERA_data
000BF1  3               
000BF1  3               .if (map_base & $FFFFFC) <> map_base
000BF1  3               	.error "Map data does not obey alignment rules"
000BF1  3               .endif
000BF1  3               
000BF1  3               .if (tile_base & $FFFFFC) <> tile_base
000BF1  3               	.error "Tile data does not obey alignment rules"
000BF1  3               .endif
000BF1  3               
000BF1  3               	; Map base
000BF1  3               	lda #<(map_base >> 2)
000BF1  3               	sta VERA_data
000BF1  3               	lda #>(map_base >> 2)
000BF1  3               	sta VERA_data
000BF1  3               
000BF1  3               	; Tile base
000BF1  3               	lda #<(tile_base >> 2)
000BF1  3               	sta VERA_data
000BF1  3               	lda #>(tile_base >> 2)
000BF1  3               	sta VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_CONFIGURE_BMP_LAYER
000BF1  3               ;   Apply the given params to a layer.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   layer			Layer (0|1)
000BF1  3               ;			mode			5: bitmap 2bpp
000BF1  3               ;							6: bitmap 4bpp
000BF1  3               ;							7: bitmap 8bpp
000BF1  3               ;			h640			(0|1) enable 640p height?
000BF1  3               ;			palette_offset	Which 16-color palette should it use?
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_CONFIGURE_BMP_LAYER layer, mode, h640, palette_offset
000BF1  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000BF1  3               
000BF1  3               	; Mode
000BF1  3               	lda #((mode << 5) | 1)
000BF1  3               	sta VERA_data
000BF1  3               
000BF1  3               	; Tile and map size
000BF1  3               	lda #(h640 << 8)
000BF1  3               	sta VERA_data
000BF1  3               
000BF1  3               	; Palette offset
000BF1  3               	lda #((layer << 4) | 7)
000BF1  3               	sta VERA_addr_low
000BF1  3               
000BF1  3               	lda #((palette_offset) >> 4)
000BF1  3               	sta VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_ENABLE_SPRITES
000BF1  3               ;   Enables sprites layer
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_ENABLE_SPRITES
000BF1  3                   VERA_SET_ADDR VRAM_sprinfo
000BF1  3                   lda #1
000BF1  3                   sta VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_DISABLE_SPRITES
000BF1  3               ;   Disables sprites layer
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_DISABLE_SPRITES
000BF1  3                   VERA_SET_ADDR VRAM_sprinfo
000BF1  3                   lda #0
000BF1  3                   sta VERA_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_SET_SPRITE
000BF1  3               ;   Set the current address channel to target
000BF1  3               ;	an indexed sprite_data entry in VRAM_sprdata
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   sprite_index	Sprite index to target
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_SET_SPRITE sprite_index
000BF1  3               	VERA_SET_ADDR (VRAM_sprdata + (sprite_index << 3))
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_CONFIGURE_SPRITE
000BF1  3               ;   Configure sprite data at the current sprite
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   data_addr	Location in VRAM where sprite data exists
000BF1  3               ;			colors			0: 4bpp
000BF1  3               ;							1: 8bpp
000BF1  3               ;			xpos			X-position
000BF1  3               ;			ypos			Y-position
000BF1  3               ;			hflip			toggle horizontal flip
000BF1  3               ;			vflip			toggle verticle flip
000BF1  3               ;			zdepth			Z-depth of sprite
000BF1  3               ;			palette_index	16-color-palette index selection
000BF1  3               ;			width, height	0: 8px
000BF1  3               ;							1: 16px
000BF1  3               ;							2: 32px
000BF1  3               ;							3: 64px
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_CONFIGURE_SPRITE data_addr, colors, xpos, ypos, hflip, vflip, zdepth, palette_index, width, height
000BF1  3               .local DATA_ADDR
000BF1  3               DATA_ADDR=(data_addr >> 5)
000BF1  3               
000BF1  3               .if ((DATA_ADDR << 5) <> data_addr)
000BF1  3               	.error "Sprite data does not obey alignment rules"
000BF1  3               .endif
000BF1  3               
000BF1  3               	VERA_WRITE <DATA_ADDR, >(DATA_ADDR | (colors << 7))
000BF1  3               	VERA_WRITE <(xpos & $0FF), >(xpos & $300), <(ypos & $0FF), >(ypos & $300)
000BF1  3               	VERA_WRITE	((hflip) | (vflip << 1) | (zdepth << 2))
000BF1  3               	VERA_WRITE ((palette_index & $0F) | (width << 4) | (height << 6))
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_SET_PALETTE
000BF1  3               ;   Set the current address channel to target
000BF1  3               ;	an indexed palette  entry in VRAM_palette
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   palette_index		Palette index to target
000BF1  3               ;			[.color_offset = 0]	Which color within the palette to target
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_SET_PALETTE palette_index, color_offset
000BF1  3               	.ifblank color_offset
000BF1  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5))
000BF1  3               	.else
000BF1  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5) + (color_offset << 1))
000BF1  3               	.endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_STREAM_OUT
000BF1  3               ;   Stream out a block of data to a location in VRAM
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   src	Source data
000BF1  3               ;			dst	Destination start location
000BF1  3               ;			size	Numbers of bytes to stream out (max 64KiB)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FB, $FC
000BF1  3               ;
000BF1  3               .macro VERA_STREAM_OUT src, dst, size
000BF1  3                   VERA_SET_ADDR dst
000BF1  3                   ldy #<(size)
000BF1  3                   ldx #>(size)
000BF1  3                   lda #<src
000BF1  3                   sta $FB
000BF1  3                   lda #>src
000BF1  3                   sta $FC
000BF1  3                   jsr vera_stream_out_data
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_ENABLE_ALL
000BF1  3               ;   Enables all layers and global sprites
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_ENABLE_ALL
000BF1  3                   VERA_SET_ADDR VRAM_layer1, 13
000BF1  3               	VERA_SELECT_ADDR 1
000BF1  3                   VERA_SET_ADDR VRAM_layer1, 13
000BF1  3               
000BF1  3               	; Layer 0
000BF1  3                   lda VERA_data
000BF1  3                   ora #$01
000BF1  3               	sta VERA_data2
000BF1  3               
000BF1  3               	; Layer 1
000BF1  3                   lda VERA_data
000BF1  3                   ora #$01
000BF1  3               	sta VERA_data2
000BF1  3               
000BF1  3               	;Sprites
000BF1  3                   lda VERA_data
000BF1  3                   ora #$01
000BF1  3               	sta VERA_data2
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_DISABLE_ALL
000BF1  3               ;   Enables all layers and global sprites
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_DISABLE_ALL
000BF1  3                   VERA_SET_ADDR VRAM_layer1, 13
000BF1  3               	VERA_SELECT_ADDR 1
000BF1  3                   VERA_SET_ADDR VRAM_layer1, 13
000BF1  3               
000BF1  3               	; Layer 0
000BF1  3                   lda VERA_data
000BF1  3                   and #$FE
000BF1  3               	sta VERA_data2
000BF1  3               
000BF1  3               	; Layer 1
000BF1  3                   lda VERA_data
000BF1  3                   and #$FE
000BF1  3               	sta VERA_data2
000BF1  3               
000BF1  3               	;Sprites
000BF1  3                   lda VERA_data
000BF1  3                   and #$FE
000BF1  3               	sta VERA_data2
000BF1  3               .endmacro
000BF1  3               
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_RESET
000BF1  3               ;   Reset the Vera to its default settings.
000BF1  3               ;	See official documentation for specifics.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_RESET
000BF1  3               	lda #$80
000BF1  3               	sta VERA_ctrl
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VERA_END_IRQ
000BF1  3               ;   Reset the Vera IRQ flag so that it generates interrupts.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VERA_END_IRQ
000BF1  3               	lda #$1
000BF1  3               	sta VERA_irq
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; VIDEO_INIT
000BF1  3               ;   Turn on the video display.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro VIDEO_INIT
000BF1  3               	VERA_SELECT_ADDR 0
000BF1  3               	VERA_SET_ADDR VRAM_composer, 1
000BF1  3               	lda #1
000BF1  3               	sta VERA_data ; VGA output
000BF1  3               .endmacro
000BF1  3               
000BF1  3               .endif ; VERA_INC
000BF1  3               
000BF1  2               .include "system.inc"
000BF1  3               .ifndef SYSTEM_INC
000BF1  3               SYSTEM_INC=1
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_HEADER_0801
000BF1  3               ;   File header of a PRG loaded at $0801. Includes
000BF1  3               ;   encoded BASIC commands to start execution
000BF1  3               ;   without needing a SYS() command.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: (none)
000BF1  3               ;
000BF1  3               .macro SYS_HEADER_0801
000BF1  3                   .ifdef HEADER_A000_IN_USE
000BF1  3                       .warning "SYS_HEADER_A000 already in use. This second call may not do what you think, and may break file size detection."
000BF1  3                   .endif
000BF1  3               
000BF1  3                   HEADER_0801_IN_USE=1
000BF1  3               
000BF1  3               ;    .org $0801
000BF1  3               ;    .byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00
000BF1  3               
000BF1  3                   .org $080D
000BF1  3               
000BF1  3                   .segment "STARTUP"
000BF1  3                   .segment "INIT"
000BF1  3                   .segment "ONCE"
000BF1  3                   .segment "CODE"
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_HEADER_A000
000BF1  3               ;   File header for a file loaded into $0A00. This
000BF1  3               ;   may include executable code and/or data, but
000BF1  3               ;   needs to be loaded in separate from the main
000BF1  3               ;   .PRG because of the address it needs to occupy.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: (none)
000BF1  3               ;
000BF1  3               .macro SYS_HEADER_A000
000BF1  3                   .ifdef HEADER_0801_IN_USE
000BF1  3                       .warning "SYS_HEADER_0801 already in use. This second call may not do what you think, and may break file size detection."
000BF1  3                   .endif
000BF1  3               
000BF1  3                   HEADER_A000_IN_USE=1
000BF1  3               
000BF1  3                   .org $0A00
000BF1  3               
000BF1  3                   .segment "STARTUP"
000BF1  3                   .segment "INIT"
000BF1  3                   .segment "ONCE"
000BF1  3                   .segment "CODE"
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_FOOTER
000BF1  3               ;   File footer for any file. This provides a warning
000BF1  3               ;   in case the file has exceeded the bounds of
000BF1  3               ;   the memory into which it is intended to be loaded.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: (none)
000BF1  3               ;
000BF1  3               .macro SYS_FOOTER
000BF1  3                   .ifndef HEADER_0801_IN_USE
000BF1  3                       .ifndef HEADER_A000_IN_USE
000BF1  3                           .warning "SYS_HEADER_* macro in use. Add SYS_HEADER_0801 or SYS_HEADER_A000, depending on where you expect to load this file."
000BF1  3                       .endif
000BF1  3                   .endif
000BF1  3               
000BF1  3                   .ifdef HEADER_0801_IN_USE
000BF1  3                       .if * > $9EFF
000BF1  3                           .warning "Program size exceeds Fixed RAM space."
000BF1  3                       .endif
000BF1  3                   .endif
000BF1  3               
000BF1  3                   .ifdef HEADER_A000_IN_USE {
000BF1  3                       .if * > $BFFF {
000BF1  3                           .warning "Program size exceeds Fixed RAM space."
000BF1  3                       .endif
000BF1  3                   .endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ;=================================================
000BF1  3               ;
000BF1  3               ;   IRQ Handling
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_SET_IRQ
000BF1  3               ;   Set where the kernal should jump to after
000BF1  3               ;   its own interrupt handling.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   .address    Label or address of IRQ handler
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro SYS_SET_IRQ address
000BF1  3                   lda #<address
000BF1  3                   sta $0314
000BF1  3                   lda #>address
000BF1  3                   sta $0315
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_END_IRQ
000BF1  3               ;   Restore registers and return control to
000BF1  3               ;   interrupted process.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y
000BF1  3               ;
000BF1  3               .macro SYS_END_IRQ
000BF1  3                   pla
000BF1  3                   tay
000BF1  3                   pla
000BF1  3                   tax
000BF1  3                   pla
000BF1  3                   rti
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ;=================================================
000BF1  3               ;
000BF1  3               ;   Random number generation
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_RAND_SEED
000BF1  3               ;   Seed the PRNG implementation with the selected
000BF1  3               ;   values.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A
000BF1  3               ;
000BF1  3               .macro SYS_RAND_SEED v0, v1, v2
000BF1  3                   lda #v0
000BF1  3                   sta Sys_rand_mem
000BF1  3                   lda #v1
000BF1  3                   sta Sys_rand_mem+1
000BF1  3                   lda #v2
000BF1  3                   sta Sys_rand_mem+2
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ;=================================================
000BF1  3               ;
000BF1  3               ;   Copy macros
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_COPY
000BF1  3               ;   Generic "copy a block of data from A to B" macro
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   src    Source address
000BF1  3               ;           dst    Destination address
000BF1  3               ;           size   Number of bytes to copy
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FB-$FF
000BF1  3               ;
000BF1  3               .macro SYS_COPY src, dst, size
000BF1  3                   lda #<src ;src to $FC $FB
000BF1  3                   sta $FB
000BF1  3                   lda #>src
000BF1  3                   sta $FC
000BF1  3                   lda #<dst ;dst to $FE $FD
000BF1  3                   sta $FD
000BF1  3                   lda #>dst
000BF1  3                   sta $FE
000BF1  3                   .if size > $FF
000BF1  3                                   ; If we have at least 1 full page to copy, then include the
000BF1  3                                   ; page copy portion which needs a 5th byte to track the number
000BF1  3                                   ; of pages to copy.
000BF1  3               
000BF1  3                       lda #>size ; number of pages to copy
000BF1  3                       sta $FF
000BF1  3               
000BF1  3                       ldy #$00 ; reset y for our loop
000BF1  3               
000BF1  3               -       lda ($FB),Y ; indirect index source memory address
000BF1  3                       sta ($FD),Y ; indirect index dest memory address
000BF1  3                       iny
000BF1  3                       bne :-       ; loop until our dest goes over 255
000BF1  3               
000BF1  3                       inc $FC     ; increment high order source memory address
000BF1  3                       inc $FE     ; increment high order dest memory address
000BF1  3               
000BF1  3                       dec $FF     ; decrement number of pages remaining
000BF1  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000BF1  3                   .endif
000BF1  3                   .if <size > 0
000BF1  3                                   ; If we're not copying exactly some number of pages, include
000BF1  3                                   ; the "copy the rest of it" section
000BF1  3                       ldy #0
000BF1  3                       ldx #<size
000BF1  3               
000BF1  3               -       lda ($FB),Y
000BF1  3                       sta ($FD),Y
000BF1  3                       iny
000BF1  3                       dex
000BF1  3                       bne :-
000BF1  3                   .endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_STREAM_OUT
000BF1  3               ;   Copy a block of data starting at a source address,
000BF1  3               ;   to exactly one destination address, because it's
000BF1  3               ;   memory-mapped IO that will auto-increment its own
000BF1  3               ;   destination.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   src    Source address
000BF1  3               ;           dst    Destination address
000BF1  3               ;           size   Number of bytes to copy
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FB-$FC, $FF
000BF1  3               ;
000BF1  3               .macro SYS_STREAM_OUT src, dst, size
000BF1  3                   lda #<src ;src to $FC $FB
000BF1  3                   sta $FB
000BF1  3                   lda #>src
000BF1  3                   sta $FC
000BF1  3               
000BF1  3                   .if size > $FF
000BF1  3                                   ; If we have at least 1 full page to copy, then include the
000BF1  3                                   ; page copy portion which needs a 5th byte to track the number
000BF1  3                                   ; of pages to copy.
000BF1  3               
000BF1  3                       lda #>size ; number of pages to copy
000BF1  3                       sta $FF
000BF1  3               
000BF1  3                       ldy #$00 ; reset y for our loop
000BF1  3               
000BF1  3               -       lda ($FB),Y ; indirect index source memory address
000BF1  3                       sta dst
000BF1  3                       iny
000BF1  3                       bne :-       ; loop until our dest goes over 255
000BF1  3               
000BF1  3                       inc $FC     ; increment high order source memory address
000BF1  3               
000BF1  3                       dec $FF     ; decrement number of pages remaining
000BF1  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000BF1  3                   .endif
000BF1  3               
000BF1  3                   .if <size > 0
000BF1  3                                   ; If we're not copying exactly some number of pages, include
000BF1  3                                   ; the "copy the rest of it" section
000BF1  3                       ldy #0
000BF1  3                       ldx #<size
000BF1  3               
000BF1  3               -       lda ($FB),Y
000BF1  3                       sta dst
000BF1  3                       iny
000BF1  3                       dex
000BF1  3                       bne :-
000BF1  3                   .endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_STREAM_IN
000BF1  3               ;   Copy a block of data from exactly one source address,
000BF1  3               ;   because it's memory-mapped IO that will auto-increment
000BF1  3               ;   its own source, to a destination starting at some address.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   src    Source address
000BF1  3               ;           dst    Destination address
000BF1  3               ;           size   Number of bytes to copy
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FD-$FF
000BF1  3               ;
000BF1  3               .macro SYS_STREAM_IN src, dst, size
000BF1  3                   lda #<dst ;dst to $FE $FD
000BF1  3                   sta $FD
000BF1  3                   lda #>dst
000BF1  3                   sta $FE
000BF1  3               
000BF1  3                   .if size > $FF
000BF1  3                                   ; If we have at least 1 full page to copy, then include the
000BF1  3                                   ; page copy portion which needs a 5th byte to track the number
000BF1  3                                   ; of pages to copy.
000BF1  3               
000BF1  3                       lda #>size ; number of pages to copy
000BF1  3                       sta $FF
000BF1  3               
000BF1  3                       ldy #$00 ; reset y for our loop
000BF1  3               @loop:
000BF1  3                       lda src
000BF1  3                       sta ($FD),Y ; indirect index dest memory address
000BF1  3                       iny
000BF1  3                       bne @loop   ; loop until our dest goes over 255
000BF1  3               
000BF1  3                       inc $FE     ; increment high order dest memory address
000BF1  3               
000BF1  3                       dec $FF     ; decrement number of pages remaining
000BF1  3                       bne @loop   ; If we still have at least 1 page to copy, go back and copy it
000BF1  3                   .endif
000BF1  3                   .if <size > 0
000BF1  3                                   ; If we're not copying exactly some number of pages, include
000BF1  3                                   ; the "copy the rest of it" section
000BF1  3                       ldy #0
000BF1  3                       ldx #<size
000BF1  3               
000BF1  3               -       lda src
000BF1  3                       sta ($FD),Y
000BF1  3                       iny
000BF1  3                       dex
000BF1  3                       bne :-
000BF1  3                   .endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; SYS_STREAM
000BF1  3               ;   Copy a block of data from exactly one source address,
000BF1  3               ;   because it's memory-mapped IO that will auto-increment
000BF1  3               ;   its own source, to exactly one destination address,
000BF1  3               ;   because it too is memory-mapped IO.
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   src    Source address
000BF1  3               ;           dst    Destination address
000BF1  3               ;           size   Number of bytes to copy
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FF
000BF1  3               ;
000BF1  3               .macro SYS_STREAM src, dst, size
000BF1  3                   .if size > $FF
000BF1  3                                   ; If we have at least 1 full page to copy, then include the
000BF1  3                                   ; page copy portion which needs a 5th byte to track the number
000BF1  3                                   ; of pages to copy.
000BF1  3               
000BF1  3                       lda #>size ; number of pages to copy
000BF1  3                       sta $FF
000BF1  3               
000BF1  3                       ldy #0 ; reset y for our loop
000BF1  3               
000BF1  3               -       lda src
000BF1  3                       sta dst
000BF1  3                       iny
000BF1  3                       bne :-       ; loop until our dest goes over 255
000BF1  3               
000BF1  3                       dec $FF     ; decrement number of pages remaining
000BF1  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000BF1  3                   .endif
000BF1  3                   .if <size > 0
000BF1  3                                   ; If we're not copying exactly some number of pages, include
000BF1  3                                   ; the "copy the rest of it" section
000BF1  3                       ldy #0
000BF1  3                       ldx #<size
000BF1  3               
000BF1  3               -       lda src
000BF1  3                       sta dst
000BF1  3                       iny
000BF1  3                       dex
000BF1  3                       bne :-
000BF1  3                   .endif
000BF1  3               .endmacro
000BF1  3               
000BF1  3               .endif ; SYSTEM_INC
000BF1  3               
000BF1  2               .include "graphics.inc"
000BF1  3               .ifndef GRAPHICS_INC
000BF1  3               GRAPHICS_INC=1
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; GRAPHICS_FADE_OUT
000BF1  3               ;   Fade out graphics to black
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   (none)
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FB-$FF
000BF1  3               ;
000BF1  3               .macro GRAPHICS_FADE_OUT
000BF1  3                   jsr graphics_fade_out
000BF1  3               .endmacro
000BF1  3               
000BF1  3               ;=================================================
000BF1  3               ; GRAPHICS_FADE_IN
000BF1  3               ;   Fade in graphics to a set of palette colors
000BF1  3               ;-------------------------------------------------
000BF1  3               ; INPUTS:   .palette_data   Final desired color data
000BF1  3               ;           .num_colors     Number of colors in the above
000BF1  3               ;
000BF1  3               ;-------------------------------------------------
000BF1  3               ; MODIFIES: A, X, Y, $FB-$FF
000BF1  3               ;
000BF1  3               .macro GRAPHICS_FADE_IN palette_data, num_colors
000BF1  3                   lda #<palette_data
000BF1  3                   sta $FB
000BF1  3                   lda #>palette_data
000BF1  3                   sta $FC
000BF1  3                   lda #num_colors
000BF1  3                   sta $FD
000BF1  3               
000BF1  3                   jsr graphics_fade_in
000BF1  3               .endmacro
000BF1  3               
000BF1  3               .endif ; GRAPHICS_INC
000BF1  3               
000BF1  2               
000BF1  2               .ifndef SPLASH_ADDR
000BF1  2                   SPLASH_ADDR=0
000BF1  2               .endif
000BF1  2               
000BF1  2               GIANT_SPLASH=1
000BF1  2               
000BF1  2               ;=================================================
000BF1  2               ;=================================================
000BF1  2               ;
000BF1  2               ;   Code
000BF1  2               ;
000BF1  2               ;-------------------------------------------------
000BF1  2               ;
000BF1  2               ; Do a splash screen with my logo.
000BF1  2               ; Return to caller when done.
000BF1  2               ;
000BF1  2               splash_do:
000BF1  2                   ; Copy the logo into video memory
000BF1  2  A9 00 8D 25      VERA_SELECT_ADDR 0
000BF5  2  9F           
000BF6  2               
000BF6  2  A9 10 8D 22      VERA_STREAM_OUT Splash_logo, SPLASH_ADDR, (Splash_logo_end - Splash_logo)
000BFA  2  9F A9 00 8D  
000BFE  2  21 9F A9 00  
000C14  2               
000C14  2                   ; VERA_SET_ADDR SPLASH_ADDR
000C14  2                   ; ldy #<(Splash_logo_end - Splash_logo)
000C14  2                   ; ldx #>(Splash_logo_end - Splash_logo)
000C14  2                   ; lda #<Splash_logo
000C14  2                   ; sta $FB
000C14  2                   ; lda #>Splash_logo
000C14  2                   ; sta $FC
000C14  2                   ; jsr vera_stream_out_data
000C14  2               
000C14  2  A9 0F 8D 22      VERA_SET_ADDR VRAM_layer1, 0
000C18  2  9F A9 20 8D  
000C1C  2  21 9F A9 00  
000C23  2  AD 23 9F         lda VERA_data
000C26  2  29 FE            and #$FE
000C28  2  8D 23 9F         sta VERA_data
000C2B  2               
000C2B  2  A9 0F 8D 22      VERA_SET_ADDR VRAM_layer2, 0
000C2F  2  9F A9 30 8D  
000C33  2  21 9F A9 00  
000C3A  2  AD 23 9F         lda VERA_data
000C3D  2  29 FE            and #$FE
000C3F  2  8D 23 9F         sta VERA_data
000C42  2               
000C42  2  A9 1F 8D 22      VERA_ENABLE_SPRITES
000C46  2  9F A9 40 8D  
000C4A  2  21 9F A9 00  
000C56  2               
000C56  2               __splash__setup_sprite:
000C56  2  A9 1F 8D 22      VERA_SET_SPRITE 0
000C5A  2  9F A9 58 8D  
000C5E  2  21 9F A9 00  
000C65  2               .if GIANT_SPLASH = 1
000C65  2  A9 00 8D 23      VERA_CONFIGURE_SPRITE SPLASH_ADDR, 1, (320-32), (240-32), 0, 0, 1, 0, 3, 3
000C69  2  9F A9 00 8D  
000C6D  2  23 9F A9 20  
000C8D  2               .else
000C8D  2                   VERA_CONFIGURE_SPRITE SPLASH_ADDR, 1, (320-16), (240-16), 0, 0, 1, 0, 2, 2
000C8D  2               .endif
000C8D  2  A9 B9 85 FB      GRAPHICS_FADE_IN Splash_palette, 2
000C91  2  A9 0C 85 FC  
000C95  2  A9 02 85 FD  
000C9C  2               
000C9C  2  A9 3C            lda #60
000C9E  2  20 E3 09         jsr sys_wait_for_frame
000CA1  2               
000CA1  2  20 08 0A         jsr graphics_fade_out
000CA4  2               
000CA4  2  A9 1F 8D 22      VERA_DISABLE_SPRITES
000CA8  2  9F A9 40 8D  
000CAC  2  21 9F A9 00  
000CB8  2               
000CB8  2  60               rts
000CB9  2               
000CB9  2               Splash_palette:
000CB9  2  00 00 FF 0F      .word $0000, $0FFF
000CBD  2               Splash_palette_end:
000CBD  2               
000CBD  2               ; .include "system.asm"
000CBD  2               .endif ; SPLASH_ASM
000CBD  2               
000CBD  1               .include "race.asm"
000CBD  2               .ifndef RACE_ASM
000CBD  2               RACE_ASM=1
000CBD  2               
000CBD  2               .include "vera.inc"
000CBD  3               
000CBD  3               .ifndef VERA_INC
000CBD  3               VERA_INC=1
000CBD  3               
000CBD  3               .include "system.inc"
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ;=================================================
000CBD  3               ;
000CBD  3               ;   Memory-mapped registers
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               
000CBD  3               .ifdef MACHINE_C64
000CBD  3               	VERA_base = $df00
000CBD  3               .else
000CBD  3               	VERA_base = $9f20
000CBD  3               .endif
000CBD  3               
000CBD  3               VERA_addr_low   = VERA_base+0
000CBD  3               VERA_addr_high  = VERA_base+1
000CBD  3               VERA_addr_bank  = VERA_base+2
000CBD  3               VERA_data       = VERA_base+3
000CBD  3               VERA_data2      = VERA_base+4
000CBD  3               VERA_ctrl       = VERA_base+5
000CBD  3               VERA_irq_ctrl   = VERA_base+6
000CBD  3               VERA_irq        = VERA_base+7
000CBD  3               
000CBD  3               VRAM_composer  = $F0000
000CBD  3               VRAM_palette   = $F1000
000CBD  3               VRAM_layer1    = $F2000
000CBD  3               VRAM_layer2    = $F3000
000CBD  3               VRAM_sprinfo   = $F4000
000CBD  3               VRAM_sprdata   = $F5800
000CBD  3               
000CBD  3               VRAM_palette0  = $F1000 + (2*16)*0
000CBD  3               VRAM_palette1  = $F1000 + (2*16)*1
000CBD  3               VRAM_palette2  = $F1000 + (2*16)*2
000CBD  3               VRAM_palette3  = $F1000 + (2*16)*3
000CBD  3               VRAM_palette4  = $F1000 + (2*16)*4
000CBD  3               VRAM_palette5  = $F1000 + (2*16)*5
000CBD  3               VRAM_palette6  = $F1000 + (2*16)*6
000CBD  3               VRAM_palette7  = $F1000 + (2*16)*7
000CBD  3               VRAM_palette8  = $F1000 + (2*16)*8
000CBD  3               VRAM_palette9  = $F1000 + (2*16)*9
000CBD  3               VRAM_palette10 = $F1000 + (2*16)*10
000CBD  3               VRAM_palette11 = $F1000 + (2*16)*11
000CBD  3               VRAM_palette12 = $F1000 + (2*16)*12
000CBD  3               VRAM_palette13 = $F1000 + (2*16)*13
000CBD  3               VRAM_palette14 = $F1000 + (2*16)*14
000CBD  3               VRAM_palette15 = $F1000 + (2*16)*15
000CBD  3               
000CBD  3               VROM_petscii   = $1F000
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ;=================================================
000CBD  3               ;
000CBD  3               ;   Macros
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_SELECT_ADDR
000CBD  3               ;   Select which address channel to configure (VERA_data vs. VERA_data2)
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   addr	0 for VERA_data
000CBD  3               ;					1 for VERA_data2
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_SELECT_ADDR addr
000CBD  3               	lda #addr
000CBD  3               	sta VERA_ctrl
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_SET_ADDR (multiple)
000CBD  3               ;   Set the current address channel's address
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   addr			VRAM address to set to
000CBD  3               ;			[stride = 1]	Address stride/auto-increment
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_SET_ADDR addr, stride
000CBD  3               	.ifnblank stride
000CBD  3               		lda #((^addr) | (stride << 4))
000CBD  3               	.else
000CBD  3               		lda #(^addr) | $10
000CBD  3               	.endif
000CBD  3               
000CBD  3               	sta VERA_addr_bank
000CBD  3               	lda #(>addr)
000CBD  3               	sta VERA_addr_high
000CBD  3               	lda #(<addr)
000CBD  3               	sta VERA_addr_low
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_WRITE (multiple)
000CBD  3               ;   Write values to VERA_data.
000CBD  3               ;	If more than 8 values are needed, consider
000CBD  3               ;	the SYS_STREAM_* family.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   v0 - v7	Values to write
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_WRITE v0, v1, v2, v3, v4, v5, v6, v7
000CBD  3               	.ifblank v0
000CBD  3               		.exitmacro
000CBD  3               	.else
000CBD  3               		lda #v0
000CBD  3               		sta VERA_data
000CBD  3               	.endif
000CBD  3               
000CBD  3               	.if .paramcount > 1
000CBD  3               		VERA_WRITE v1, v2, v3, v4, v5, v6, v7
000CBD  3               	.endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VPEEK
000CBD  3               ;   It's... VPEEK(), but in assembly.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   addr	VRAM address to read from.
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VPEEK addr
000CBD  3               	VERA_SET_ADDR addr
000CBD  3               	lda VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_ENABLE_LAYER
000CBD  3               ;   Enable the specified layer
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   layer	Which layer to enable
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_ENABLE_LAYER layer
000CBD  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000CBD  3               	lda VERA_data
000CBD  3               	ora #$01
000CBD  3               	sta VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_DISABLE_LAYER
000CBD  3               ;   Disable the specified layer
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   layer	Which layer to enable
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_DISABLE_LAYER layer
000CBD  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 0
000CBD  3               	lda VERA_data
000CBD  3               	and #$FE
000CBD  3               	sta VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_CONFIGURE_TILE_LAYER
000CBD  3               ;   Apply the given params to a layer.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   layer			Layer (0|1)
000CBD  3               ;			enable			0: disable layer
000CBD  3               ;							1: enable layer
000CBD  3               ;			mode			0: text 1bpp, 16 color f/g
000CBD  3               ;							1: text 1bpp, 256 color f
000CBD  3               ;							2: tile 2bpp
000CBD  3               ;							3: tile 4bpp
000CBD  3               ;							4: tile 8bpp
000CBD  3               ;			w16_tiles		(0|1) enable 16-width tiles?
000CBD  3               ;			h16_tiles		(0|1) enable 16-height tiles?
000CBD  3               ;			mapw, maph		0: 32 tiles/chars
000CBD  3               ;							1: 64 tiles/chars
000CBD  3               ;							2: 128 tiles/chars
000CBD  3               ;							3: 256 tiles/chars
000CBD  3               ;			map_base		Start address of map indices (4-byte align)
000CBD  3               ;			tile_base		Start address of tile indices (4-byte align)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_CONFIGURE_TILE_LAYER layer, enable, mode, w16_tiles, h16_tiles, mapw, maph, map_base, tile_base
000CBD  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000CBD  3               
000CBD  3               	; Mode
000CBD  3               	lda #((mode << 5) | enable)
000CBD  3               	sta VERA_data
000CBD  3               
000CBD  3               	; Tile and map size
000CBD  3               	lda #((h16_tiles << 5) | (w16_tiles << 4) | (maph << 2) | (mapw))
000CBD  3               	sta VERA_data
000CBD  3               
000CBD  3               .if (map_base & $FFFFFC) <> map_base
000CBD  3               	.error "Map data does not obey alignment rules"
000CBD  3               .endif
000CBD  3               
000CBD  3               .if (tile_base & $FFFFFC) <> tile_base
000CBD  3               	.error "Tile data does not obey alignment rules"
000CBD  3               .endif
000CBD  3               
000CBD  3               	; Map base
000CBD  3               	lda #<(map_base >> 2)
000CBD  3               	sta VERA_data
000CBD  3               	lda #>(map_base >> 2)
000CBD  3               	sta VERA_data
000CBD  3               
000CBD  3               	; Tile base
000CBD  3               	lda #<(tile_base >> 2)
000CBD  3               	sta VERA_data
000CBD  3               	lda #>(tile_base >> 2)
000CBD  3               	sta VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_CONFIGURE_BMP_LAYER
000CBD  3               ;   Apply the given params to a layer.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   layer			Layer (0|1)
000CBD  3               ;			mode			5: bitmap 2bpp
000CBD  3               ;							6: bitmap 4bpp
000CBD  3               ;							7: bitmap 8bpp
000CBD  3               ;			h640			(0|1) enable 640p height?
000CBD  3               ;			palette_offset	Which 16-color palette should it use?
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_CONFIGURE_BMP_LAYER layer, mode, h640, palette_offset
000CBD  3               	VERA_SET_ADDR (VRAM_layer1 + (layer << 4)), 1
000CBD  3               
000CBD  3               	; Mode
000CBD  3               	lda #((mode << 5) | 1)
000CBD  3               	sta VERA_data
000CBD  3               
000CBD  3               	; Tile and map size
000CBD  3               	lda #(h640 << 8)
000CBD  3               	sta VERA_data
000CBD  3               
000CBD  3               	; Palette offset
000CBD  3               	lda #((layer << 4) | 7)
000CBD  3               	sta VERA_addr_low
000CBD  3               
000CBD  3               	lda #((palette_offset) >> 4)
000CBD  3               	sta VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_ENABLE_SPRITES
000CBD  3               ;   Enables sprites layer
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_ENABLE_SPRITES
000CBD  3                   VERA_SET_ADDR VRAM_sprinfo
000CBD  3                   lda #1
000CBD  3                   sta VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_DISABLE_SPRITES
000CBD  3               ;   Disables sprites layer
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_DISABLE_SPRITES
000CBD  3                   VERA_SET_ADDR VRAM_sprinfo
000CBD  3                   lda #0
000CBD  3                   sta VERA_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_SET_SPRITE
000CBD  3               ;   Set the current address channel to target
000CBD  3               ;	an indexed sprite_data entry in VRAM_sprdata
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   sprite_index	Sprite index to target
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_SET_SPRITE sprite_index
000CBD  3               	VERA_SET_ADDR (VRAM_sprdata + (sprite_index << 3))
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_CONFIGURE_SPRITE
000CBD  3               ;   Configure sprite data at the current sprite
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   data_addr	Location in VRAM where sprite data exists
000CBD  3               ;			colors			0: 4bpp
000CBD  3               ;							1: 8bpp
000CBD  3               ;			xpos			X-position
000CBD  3               ;			ypos			Y-position
000CBD  3               ;			hflip			toggle horizontal flip
000CBD  3               ;			vflip			toggle verticle flip
000CBD  3               ;			zdepth			Z-depth of sprite
000CBD  3               ;			palette_index	16-color-palette index selection
000CBD  3               ;			width, height	0: 8px
000CBD  3               ;							1: 16px
000CBD  3               ;							2: 32px
000CBD  3               ;							3: 64px
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_CONFIGURE_SPRITE data_addr, colors, xpos, ypos, hflip, vflip, zdepth, palette_index, width, height
000CBD  3               .local DATA_ADDR
000CBD  3               DATA_ADDR=(data_addr >> 5)
000CBD  3               
000CBD  3               .if ((DATA_ADDR << 5) <> data_addr)
000CBD  3               	.error "Sprite data does not obey alignment rules"
000CBD  3               .endif
000CBD  3               
000CBD  3               	VERA_WRITE <DATA_ADDR, >(DATA_ADDR | (colors << 7))
000CBD  3               	VERA_WRITE <(xpos & $0FF), >(xpos & $300), <(ypos & $0FF), >(ypos & $300)
000CBD  3               	VERA_WRITE	((hflip) | (vflip << 1) | (zdepth << 2))
000CBD  3               	VERA_WRITE ((palette_index & $0F) | (width << 4) | (height << 6))
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_SET_PALETTE
000CBD  3               ;   Set the current address channel to target
000CBD  3               ;	an indexed palette  entry in VRAM_palette
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   palette_index		Palette index to target
000CBD  3               ;			[.color_offset = 0]	Which color within the palette to target
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_SET_PALETTE palette_index, color_offset
000CBD  3               	.ifblank color_offset
000CBD  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5))
000CBD  3               	.else
000CBD  3               		VERA_SET_ADDR (VRAM_palette + (palette_index << 5) + (color_offset << 1))
000CBD  3               	.endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_STREAM_OUT
000CBD  3               ;   Stream out a block of data to a location in VRAM
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   src	Source data
000CBD  3               ;			dst	Destination start location
000CBD  3               ;			size	Numbers of bytes to stream out (max 64KiB)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FB, $FC
000CBD  3               ;
000CBD  3               .macro VERA_STREAM_OUT src, dst, size
000CBD  3                   VERA_SET_ADDR dst
000CBD  3                   ldy #<(size)
000CBD  3                   ldx #>(size)
000CBD  3                   lda #<src
000CBD  3                   sta $FB
000CBD  3                   lda #>src
000CBD  3                   sta $FC
000CBD  3                   jsr vera_stream_out_data
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_ENABLE_ALL
000CBD  3               ;   Enables all layers and global sprites
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_ENABLE_ALL
000CBD  3                   VERA_SET_ADDR VRAM_layer1, 13
000CBD  3               	VERA_SELECT_ADDR 1
000CBD  3                   VERA_SET_ADDR VRAM_layer1, 13
000CBD  3               
000CBD  3               	; Layer 0
000CBD  3                   lda VERA_data
000CBD  3                   ora #$01
000CBD  3               	sta VERA_data2
000CBD  3               
000CBD  3               	; Layer 1
000CBD  3                   lda VERA_data
000CBD  3                   ora #$01
000CBD  3               	sta VERA_data2
000CBD  3               
000CBD  3               	;Sprites
000CBD  3                   lda VERA_data
000CBD  3                   ora #$01
000CBD  3               	sta VERA_data2
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_DISABLE_ALL
000CBD  3               ;   Enables all layers and global sprites
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_DISABLE_ALL
000CBD  3                   VERA_SET_ADDR VRAM_layer1, 13
000CBD  3               	VERA_SELECT_ADDR 1
000CBD  3                   VERA_SET_ADDR VRAM_layer1, 13
000CBD  3               
000CBD  3               	; Layer 0
000CBD  3                   lda VERA_data
000CBD  3                   and #$FE
000CBD  3               	sta VERA_data2
000CBD  3               
000CBD  3               	; Layer 1
000CBD  3                   lda VERA_data
000CBD  3                   and #$FE
000CBD  3               	sta VERA_data2
000CBD  3               
000CBD  3               	;Sprites
000CBD  3                   lda VERA_data
000CBD  3                   and #$FE
000CBD  3               	sta VERA_data2
000CBD  3               .endmacro
000CBD  3               
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_RESET
000CBD  3               ;   Reset the Vera to its default settings.
000CBD  3               ;	See official documentation for specifics.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_RESET
000CBD  3               	lda #$80
000CBD  3               	sta VERA_ctrl
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VERA_END_IRQ
000CBD  3               ;   Reset the Vera IRQ flag so that it generates interrupts.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VERA_END_IRQ
000CBD  3               	lda #$1
000CBD  3               	sta VERA_irq
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; VIDEO_INIT
000CBD  3               ;   Turn on the video display.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro VIDEO_INIT
000CBD  3               	VERA_SELECT_ADDR 0
000CBD  3               	VERA_SET_ADDR VRAM_composer, 1
000CBD  3               	lda #1
000CBD  3               	sta VERA_data ; VGA output
000CBD  3               .endmacro
000CBD  3               
000CBD  3               .endif ; VERA_INC
000CBD  3               
000CBD  2               .include "system.inc"
000CBD  3               .ifndef SYSTEM_INC
000CBD  3               SYSTEM_INC=1
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_HEADER_0801
000CBD  3               ;   File header of a PRG loaded at $0801. Includes
000CBD  3               ;   encoded BASIC commands to start execution
000CBD  3               ;   without needing a SYS() command.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: (none)
000CBD  3               ;
000CBD  3               .macro SYS_HEADER_0801
000CBD  3                   .ifdef HEADER_A000_IN_USE
000CBD  3                       .warning "SYS_HEADER_A000 already in use. This second call may not do what you think, and may break file size detection."
000CBD  3                   .endif
000CBD  3               
000CBD  3                   HEADER_0801_IN_USE=1
000CBD  3               
000CBD  3               ;    .org $0801
000CBD  3               ;    .byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00
000CBD  3               
000CBD  3                   .org $080D
000CBD  3               
000CBD  3                   .segment "STARTUP"
000CBD  3                   .segment "INIT"
000CBD  3                   .segment "ONCE"
000CBD  3                   .segment "CODE"
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_HEADER_A000
000CBD  3               ;   File header for a file loaded into $0A00. This
000CBD  3               ;   may include executable code and/or data, but
000CBD  3               ;   needs to be loaded in separate from the main
000CBD  3               ;   .PRG because of the address it needs to occupy.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: (none)
000CBD  3               ;
000CBD  3               .macro SYS_HEADER_A000
000CBD  3                   .ifdef HEADER_0801_IN_USE
000CBD  3                       .warning "SYS_HEADER_0801 already in use. This second call may not do what you think, and may break file size detection."
000CBD  3                   .endif
000CBD  3               
000CBD  3                   HEADER_A000_IN_USE=1
000CBD  3               
000CBD  3                   .org $0A00
000CBD  3               
000CBD  3                   .segment "STARTUP"
000CBD  3                   .segment "INIT"
000CBD  3                   .segment "ONCE"
000CBD  3                   .segment "CODE"
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_FOOTER
000CBD  3               ;   File footer for any file. This provides a warning
000CBD  3               ;   in case the file has exceeded the bounds of
000CBD  3               ;   the memory into which it is intended to be loaded.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: (none)
000CBD  3               ;
000CBD  3               .macro SYS_FOOTER
000CBD  3                   .ifndef HEADER_0801_IN_USE
000CBD  3                       .ifndef HEADER_A000_IN_USE
000CBD  3                           .warning "SYS_HEADER_* macro in use. Add SYS_HEADER_0801 or SYS_HEADER_A000, depending on where you expect to load this file."
000CBD  3                       .endif
000CBD  3                   .endif
000CBD  3               
000CBD  3                   .ifdef HEADER_0801_IN_USE
000CBD  3                       .if * > $9EFF
000CBD  3                           .warning "Program size exceeds Fixed RAM space."
000CBD  3                       .endif
000CBD  3                   .endif
000CBD  3               
000CBD  3                   .ifdef HEADER_A000_IN_USE {
000CBD  3                       .if * > $BFFF {
000CBD  3                           .warning "Program size exceeds Fixed RAM space."
000CBD  3                       .endif
000CBD  3                   .endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ;=================================================
000CBD  3               ;
000CBD  3               ;   IRQ Handling
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_SET_IRQ
000CBD  3               ;   Set where the kernal should jump to after
000CBD  3               ;   its own interrupt handling.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   .address    Label or address of IRQ handler
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro SYS_SET_IRQ address
000CBD  3                   lda #<address
000CBD  3                   sta $0314
000CBD  3                   lda #>address
000CBD  3                   sta $0315
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_END_IRQ
000CBD  3               ;   Restore registers and return control to
000CBD  3               ;   interrupted process.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y
000CBD  3               ;
000CBD  3               .macro SYS_END_IRQ
000CBD  3                   pla
000CBD  3                   tay
000CBD  3                   pla
000CBD  3                   tax
000CBD  3                   pla
000CBD  3                   rti
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ;=================================================
000CBD  3               ;
000CBD  3               ;   Random number generation
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_RAND_SEED
000CBD  3               ;   Seed the PRNG implementation with the selected
000CBD  3               ;   values.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A
000CBD  3               ;
000CBD  3               .macro SYS_RAND_SEED v0, v1, v2
000CBD  3                   lda #v0
000CBD  3                   sta Sys_rand_mem
000CBD  3                   lda #v1
000CBD  3                   sta Sys_rand_mem+1
000CBD  3                   lda #v2
000CBD  3                   sta Sys_rand_mem+2
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ;=================================================
000CBD  3               ;
000CBD  3               ;   Copy macros
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_COPY
000CBD  3               ;   Generic "copy a block of data from A to B" macro
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   src    Source address
000CBD  3               ;           dst    Destination address
000CBD  3               ;           size   Number of bytes to copy
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FB-$FF
000CBD  3               ;
000CBD  3               .macro SYS_COPY src, dst, size
000CBD  3                   lda #<src ;src to $FC $FB
000CBD  3                   sta $FB
000CBD  3                   lda #>src
000CBD  3                   sta $FC
000CBD  3                   lda #<dst ;dst to $FE $FD
000CBD  3                   sta $FD
000CBD  3                   lda #>dst
000CBD  3                   sta $FE
000CBD  3                   .if size > $FF
000CBD  3                                   ; If we have at least 1 full page to copy, then include the
000CBD  3                                   ; page copy portion which needs a 5th byte to track the number
000CBD  3                                   ; of pages to copy.
000CBD  3               
000CBD  3                       lda #>size ; number of pages to copy
000CBD  3                       sta $FF
000CBD  3               
000CBD  3                       ldy #$00 ; reset y for our loop
000CBD  3               
000CBD  3               -       lda ($FB),Y ; indirect index source memory address
000CBD  3                       sta ($FD),Y ; indirect index dest memory address
000CBD  3                       iny
000CBD  3                       bne :-       ; loop until our dest goes over 255
000CBD  3               
000CBD  3                       inc $FC     ; increment high order source memory address
000CBD  3                       inc $FE     ; increment high order dest memory address
000CBD  3               
000CBD  3                       dec $FF     ; decrement number of pages remaining
000CBD  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000CBD  3                   .endif
000CBD  3                   .if <size > 0
000CBD  3                                   ; If we're not copying exactly some number of pages, include
000CBD  3                                   ; the "copy the rest of it" section
000CBD  3                       ldy #0
000CBD  3                       ldx #<size
000CBD  3               
000CBD  3               -       lda ($FB),Y
000CBD  3                       sta ($FD),Y
000CBD  3                       iny
000CBD  3                       dex
000CBD  3                       bne :-
000CBD  3                   .endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_STREAM_OUT
000CBD  3               ;   Copy a block of data starting at a source address,
000CBD  3               ;   to exactly one destination address, because it's
000CBD  3               ;   memory-mapped IO that will auto-increment its own
000CBD  3               ;   destination.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   src    Source address
000CBD  3               ;           dst    Destination address
000CBD  3               ;           size   Number of bytes to copy
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FB-$FC, $FF
000CBD  3               ;
000CBD  3               .macro SYS_STREAM_OUT src, dst, size
000CBD  3                   lda #<src ;src to $FC $FB
000CBD  3                   sta $FB
000CBD  3                   lda #>src
000CBD  3                   sta $FC
000CBD  3               
000CBD  3                   .if size > $FF
000CBD  3                                   ; If we have at least 1 full page to copy, then include the
000CBD  3                                   ; page copy portion which needs a 5th byte to track the number
000CBD  3                                   ; of pages to copy.
000CBD  3               
000CBD  3                       lda #>size ; number of pages to copy
000CBD  3                       sta $FF
000CBD  3               
000CBD  3                       ldy #$00 ; reset y for our loop
000CBD  3               
000CBD  3               -       lda ($FB),Y ; indirect index source memory address
000CBD  3                       sta dst
000CBD  3                       iny
000CBD  3                       bne :-       ; loop until our dest goes over 255
000CBD  3               
000CBD  3                       inc $FC     ; increment high order source memory address
000CBD  3               
000CBD  3                       dec $FF     ; decrement number of pages remaining
000CBD  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000CBD  3                   .endif
000CBD  3               
000CBD  3                   .if <size > 0
000CBD  3                                   ; If we're not copying exactly some number of pages, include
000CBD  3                                   ; the "copy the rest of it" section
000CBD  3                       ldy #0
000CBD  3                       ldx #<size
000CBD  3               
000CBD  3               -       lda ($FB),Y
000CBD  3                       sta dst
000CBD  3                       iny
000CBD  3                       dex
000CBD  3                       bne :-
000CBD  3                   .endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_STREAM_IN
000CBD  3               ;   Copy a block of data from exactly one source address,
000CBD  3               ;   because it's memory-mapped IO that will auto-increment
000CBD  3               ;   its own source, to a destination starting at some address.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   src    Source address
000CBD  3               ;           dst    Destination address
000CBD  3               ;           size   Number of bytes to copy
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FD-$FF
000CBD  3               ;
000CBD  3               .macro SYS_STREAM_IN src, dst, size
000CBD  3                   lda #<dst ;dst to $FE $FD
000CBD  3                   sta $FD
000CBD  3                   lda #>dst
000CBD  3                   sta $FE
000CBD  3               
000CBD  3                   .if size > $FF
000CBD  3                                   ; If we have at least 1 full page to copy, then include the
000CBD  3                                   ; page copy portion which needs a 5th byte to track the number
000CBD  3                                   ; of pages to copy.
000CBD  3               
000CBD  3                       lda #>size ; number of pages to copy
000CBD  3                       sta $FF
000CBD  3               
000CBD  3                       ldy #$00 ; reset y for our loop
000CBD  3               @loop:
000CBD  3                       lda src
000CBD  3                       sta ($FD),Y ; indirect index dest memory address
000CBD  3                       iny
000CBD  3                       bne @loop   ; loop until our dest goes over 255
000CBD  3               
000CBD  3                       inc $FE     ; increment high order dest memory address
000CBD  3               
000CBD  3                       dec $FF     ; decrement number of pages remaining
000CBD  3                       bne @loop   ; If we still have at least 1 page to copy, go back and copy it
000CBD  3                   .endif
000CBD  3                   .if <size > 0
000CBD  3                                   ; If we're not copying exactly some number of pages, include
000CBD  3                                   ; the "copy the rest of it" section
000CBD  3                       ldy #0
000CBD  3                       ldx #<size
000CBD  3               
000CBD  3               -       lda src
000CBD  3                       sta ($FD),Y
000CBD  3                       iny
000CBD  3                       dex
000CBD  3                       bne :-
000CBD  3                   .endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; SYS_STREAM
000CBD  3               ;   Copy a block of data from exactly one source address,
000CBD  3               ;   because it's memory-mapped IO that will auto-increment
000CBD  3               ;   its own source, to exactly one destination address,
000CBD  3               ;   because it too is memory-mapped IO.
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   src    Source address
000CBD  3               ;           dst    Destination address
000CBD  3               ;           size   Number of bytes to copy
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FF
000CBD  3               ;
000CBD  3               .macro SYS_STREAM src, dst, size
000CBD  3                   .if size > $FF
000CBD  3                                   ; If we have at least 1 full page to copy, then include the
000CBD  3                                   ; page copy portion which needs a 5th byte to track the number
000CBD  3                                   ; of pages to copy.
000CBD  3               
000CBD  3                       lda #>size ; number of pages to copy
000CBD  3                       sta $FF
000CBD  3               
000CBD  3                       ldy #0 ; reset y for our loop
000CBD  3               
000CBD  3               -       lda src
000CBD  3                       sta dst
000CBD  3                       iny
000CBD  3                       bne :-       ; loop until our dest goes over 255
000CBD  3               
000CBD  3                       dec $FF     ; decrement number of pages remaining
000CBD  3                       bne :-       ; If we still have at least 1 page to copy, go back and copy it
000CBD  3                   .endif
000CBD  3                   .if <size > 0
000CBD  3                                   ; If we're not copying exactly some number of pages, include
000CBD  3                                   ; the "copy the rest of it" section
000CBD  3                       ldy #0
000CBD  3                       ldx #<size
000CBD  3               
000CBD  3               -       lda src
000CBD  3                       sta dst
000CBD  3                       iny
000CBD  3                       dex
000CBD  3                       bne :-
000CBD  3                   .endif
000CBD  3               .endmacro
000CBD  3               
000CBD  3               .endif ; SYSTEM_INC
000CBD  3               
000CBD  2               .include "graphics.inc"
000CBD  3               .ifndef GRAPHICS_INC
000CBD  3               GRAPHICS_INC=1
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; GRAPHICS_FADE_OUT
000CBD  3               ;   Fade out graphics to black
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   (none)
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FB-$FF
000CBD  3               ;
000CBD  3               .macro GRAPHICS_FADE_OUT
000CBD  3                   jsr graphics_fade_out
000CBD  3               .endmacro
000CBD  3               
000CBD  3               ;=================================================
000CBD  3               ; GRAPHICS_FADE_IN
000CBD  3               ;   Fade in graphics to a set of palette colors
000CBD  3               ;-------------------------------------------------
000CBD  3               ; INPUTS:   .palette_data   Final desired color data
000CBD  3               ;           .num_colors     Number of colors in the above
000CBD  3               ;
000CBD  3               ;-------------------------------------------------
000CBD  3               ; MODIFIES: A, X, Y, $FB-$FF
000CBD  3               ;
000CBD  3               .macro GRAPHICS_FADE_IN palette_data, num_colors
000CBD  3                   lda #<palette_data
000CBD  3                   sta $FB
000CBD  3                   lda #>palette_data
000CBD  3                   sta $FC
000CBD  3                   lda #num_colors
000CBD  3                   sta $FD
000CBD  3               
000CBD  3                   jsr graphics_fade_in
000CBD  3               .endmacro
000CBD  3               
000CBD  3               .endif ; GRAPHICS_INC
000CBD  3               
000CBD  2               
000CBD  2               RACE_MOUNTAINS_BG_ADDR=0
000CBD  2               RACE_MOUNTAINS_BG_SIZE=$4000 ; 128*64*2
000CBD  2               
000CBD  2               RACE_FOREST_BG_ADDR=$4000
000CBD  2               RACE_FOREST_BG_SIZE=$4000 ; 128*64*2
000CBD  2               
000CBD  2               RACE_MOUNTAINS_BG_TILES_ADDR=$8000
000CBD  2               RACE_MOUNTAINS_BG_TILES_SIZE=$80 ; ((4 * 8) * 4) ; 4 tiles
000CBD  2               
000CBD  2               RACE_FOREST_BG_TILES_ADDR=$8080 ; (RACE_MOUNTAINS_BG_TILES_ADDR + RACE_MOUNTAINS_BG_TILES_SIZE)
000CBD  2               RACE_FOREST_BG_TILES_SIZE=$40 ; ((4 * 8) * 2) ; 2 tiles
000CBD  2               
000CBD  2               RACE_CAR_ADDR=$80C0 ; (RACE_FOREST_BG_TILES_ADDR + RACE_FOREST_BG_TILES_SIZE), aligned to 5 bits
000CBD  2               RACE_CAR_SIZE=$1000 ; ((64 * 64) * 1)
000CBD  2               
000CBD  2               ;=================================================
000CBD  2               ;=================================================
000CBD  2               ;
000CBD  2               ;   Code
000CBD  2               ;
000CBD  2               ;-------------------------------------------------
000CBD  2               ;
000CBD  2               ; Do a RACE screen with my logo.
000CBD  2               ; Return to caller when done.
000CBD  2               ;
000CBD  2               race_do:
000CBD  2                   ; Copy data into video memory
000CBD  2  A9 00 8D 25      VERA_SELECT_ADDR 0
000CC1  2  9F           
000CC2  2  A9 10 8D 22      VERA_STREAM_OUT Race_mountains_map, RACE_MOUNTAINS_BG_ADDR, RACE_MOUNTAINS_BG_SIZE
000CC6  2  9F A9 00 8D  
000CCA  2  21 9F A9 00  
000CE0  2  A9 10 8D 22      VERA_STREAM_OUT Race_forest_map, RACE_FOREST_BG_ADDR, RACE_FOREST_BG_SIZE
000CE4  2  9F A9 40 8D  
000CE8  2  21 9F A9 00  
000CFE  2  A9 10 8D 22      VERA_STREAM_OUT Race_mountains_tiles, RACE_MOUNTAINS_BG_TILES_ADDR, RACE_MOUNTAINS_BG_SIZE
000D02  2  9F A9 80 8D  
000D06  2  21 9F A9 00  
000D1C  2  A9 10 8D 22      VERA_STREAM_OUT Race_forest_tiles, RACE_FOREST_BG_TILES_ADDR, RACE_FOREST_BG_SIZE
000D20  2  9F A9 80 8D  
000D24  2  21 9F A9 80  
000D3A  2  A9 10 8D 22      VERA_STREAM_OUT Race_car, RACE_CAR_ADDR, RACE_CAR_SIZE
000D3E  2  9F A9 80 8D  
000D42  2  21 9F A9 C0  
000D58  2  A9 1F 8D 22      VERA_STREAM_OUT Race_mountains_palette, VRAM_palette0, 6*2
000D5C  2  9F A9 10 8D  
000D60  2  21 9F A9 00  
000D76  2  A9 1F 8D 22      VERA_STREAM_OUT Race_forest_palette, VRAM_palette1, 6*2
000D7A  2  9F A9 10 8D  
000D7E  2  21 9F A9 20  
000D94  2  A9 1F 8D 22      VERA_STREAM_OUT Race_car_palette, VRAM_palette2, 6*2
000D98  2  9F A9 10 8D  
000D9C  2  21 9F A9 40  
000DB2  2               
000DB2  2               __race__setup_scene:
000DB2  2  A9 1F 8D 22      VERA_CONFIGURE_TILE_LAYER 0, 0, 3, 0, 0, 2, 1, RACE_MOUNTAINS_BG_ADDR, RACE_MOUNTAINS_BG_TILES_ADDR
000DB6  2  9F A9 20 8D  
000DBA  2  21 9F A9 00  
000DDF  2  A9 1F 8D 22      VERA_CONFIGURE_TILE_LAYER 1, 0, 3, 0, 0, 2, 1, RACE_FOREST_BG_ADDR, RACE_FOREST_BG_TILES_ADDR
000DE3  2  9F A9 20 8D  
000DE7  2  21 9F A9 10  
000E0C  2               
000E0C  2  A9 1F 8D 22      VERA_SET_SPRITE 0
000E10  2  9F A9 58 8D  
000E14  2  21 9F A9 00  
000E1B  2  A9 06 8D 23      VERA_CONFIGURE_SPRITE RACE_CAR_ADDR, 0, (320-32), (240-32), 0, 0, 1, 2, 3, 3
000E1F  2  9F A9 04 8D  
000E23  2  23 9F A9 20  
000E43  2               
000E43  2               __race__begin:
000E43  2  A9 1F 8D 22      VERA_ENABLE_SPRITES
000E47  2  9F A9 40 8D  
000E4B  2  21 9F A9 00  
000E57  2  A9 0F 8D 22      VERA_ENABLE_LAYER 0
000E5B  2  9F A9 20 8D  
000E5F  2  21 9F A9 00  
000E6E  2                   ; VERA_ENABLE_ALL
000E6E  2               
000E6E  2  A9 00            lda #0
000E70  2  20 E3 09         jsr sys_wait_for_frame
000E73  2  4C 73 0E         jmp *
000E76  2               
000E76  2               __race__cleanup:
000E76  2  A9 1F 8D 22      VERA_DISABLE_SPRITES
000E7A  2  9F A9 40 8D  
000E7E  2  21 9F A9 00  
000E8A  2  60               rts
000E8B  2               
000E8B  2               Race_mountains_palette:
000E8B  2  00 00 08 00      .word $0000, $0008, $000F, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000
000E8F  2  0F 00 00 00  
000E93  2  00 00 00 00  
000EAB  2               Race_palette_end:
000EAB  2               Race_forest_palette:
000EAB  2  00 00 80 00      .word $0000, $0080, $00F0, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000
000EAF  2  F0 00 00 00  
000EB3  2  00 00 00 00  
000ECB  2               Race_forest_palette_end:
000ECB  2               Race_car_palette:
000ECB  2  00 00 00 08      .word $0000, $0800, $0F00, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000
000ECF  2  00 0F 00 00  
000ED3  2  00 00 00 00  
000EEB  2               Race_car_palette_end:
000EEB  2               
000EEB  2               Race_tiles:
000EEB  2               Race_mountains_tiles:
000EEB  2               Race_mountains_blank_tile:
000EEB  2  00 00 00 00      .byte $00, $00, $00, $00
000EEF  2  00 00 00 00      .byte $00, $00, $00, $00
000EF3  2  00 00 00 00      .byte $00, $00, $00, $00
000EF7  2  00 00 00 00      .byte $00, $00, $00, $00
000EFB  2  00 00 00 00      .byte $00, $00, $00, $00
000EFF  2  00 00 00 00      .byte $00, $00, $00, $00
000F03  2  00 00 00 00      .byte $00, $00, $00, $00
000F07  2  00 00 00 00      .byte $00, $00, $00, $00
000F0B  2               
000F0B  2               Race_mountains_tile_sky:
000F0B  2  22 22 22 22      .byte $22, $22, $22, $22
000F0F  2  22 22 22 22      .byte $22, $22, $22, $22
000F13  2  22 22 22 22      .byte $22, $22, $22, $22
000F17  2  22 22 22 22      .byte $22, $22, $22, $22
000F1B  2  22 22 22 22      .byte $22, $22, $22, $22
000F1F  2  22 22 22 22      .byte $22, $22, $22, $22
000F23  2  22 22 22 22      .byte $22, $22, $22, $22
000F27  2  22 22 22 22      .byte $22, $22, $22, $22
000F2B  2               
000F2B  2               Race_mountains_tile_sky_cloud:
000F2B  2  22 22 22 22      .byte $22, $22, $22, $22
000F2F  2  22 22 44 42      .byte $22, $22, $44, $42
000F33  2  22 44 44 44      .byte $22, $44, $44, $44
000F37  2  24 44 44 44      .byte $24, $44, $44, $44
000F3B  2  44 44 44 44      .byte $44, $44, $44, $44
000F3F  2  44 44 44 44      .byte $44, $44, $44, $44
000F43  2  24 44 44 44      .byte $24, $44, $44, $44
000F47  2  22 24 44 24      .byte $22, $24, $44, $24
000F4B  2               
000F4B  2               Race_mountains_tile_mountain:
000F4B  2  22 22 22 22      .byte $22, $22, $22, $22
000F4F  2  22 22 22 21      .byte $22, $22, $22, $21
000F53  2  22 22 22 11      .byte $22, $22, $22, $11
000F57  2  22 22 21 11      .byte $22, $22, $21, $11
000F5B  2  22 22 11 11      .byte $22, $22, $11, $11
000F5F  2  22 21 11 11      .byte $22, $21, $11, $11
000F63  2  22 11 11 11      .byte $22, $11, $11, $11
000F67  2  21 11 11 11      .byte $21, $11, $11, $11
000F6B  2               Race_mountains_tiles_end:
000F6B  2               
000F6B  2               Race_forest_tiles:
000F6B  2               Race_forest_blank_tile:
000F6B  2  00 00 00 00      .byte $00, $00, $00, $00
000F6F  2  00 00 00 00      .byte $00, $00, $00, $00
000F73  2  00 00 00 00      .byte $00, $00, $00, $00
000F77  2  00 00 00 00      .byte $00, $00, $00, $00
000F7B  2  00 00 00 00      .byte $00, $00, $00, $00
000F7F  2  00 00 00 00      .byte $00, $00, $00, $00
000F83  2  00 00 00 00      .byte $00, $00, $00, $00
000F87  2  00 00 00 00      .byte $00, $00, $00, $00
000F8B  2               
000F8B  2               Race_forest_tile_top:
000F8B  2  44 44 44 44      .byte $44, $44, $44, $44
000F8F  2  44 44 44 44      .byte $44, $44, $44, $44
000F93  2  44 44 44 44      .byte $44, $44, $44, $44
000F97  2  44 44 44 44      .byte $44, $44, $44, $44
000F9B  2  44 44 44 44      .byte $44, $44, $44, $44
000F9F  2  44 44 44 44      .byte $44, $44, $44, $44
000FA3  2  44 44 44 44      .byte $44, $44, $44, $44
000FA7  2  44 44 44 44      .byte $44, $44, $44, $44
000FAB  2               Race_forest_tiles_end:
000FAB  2               
000FAB  2               Race_car:
000FAB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
000FAF  2  00 00 00 00  
000FB3  2  00 00 00 00  
000FCB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
000FCF  2  00 00 00 00  
000FD3  2  00 00 00 00  
000FEB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
000FEF  2  00 00 00 00  
000FF3  2  00 00 00 00  
00100B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00100F  2  00 00 00 00  
001013  2  00 00 00 00  
00102B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00102F  2  00 00 00 00  
001033  2  00 00 00 11  
00104B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00104F  2  00 00 00 00  
001053  2  00 00 00 11  
00106B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00106F  2  00 00 00 00  
001073  2  00 11 11 00  
00108B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00108F  2  00 00 00 00  
001093  2  00 11 11 00  
0010AB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00
0010AF  2  00 00 00 11  
0010B3  2  11 00 00 00  
0010CB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00
0010CF  2  00 00 00 11  
0010D3  2  11 00 00 00  
0010EB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00
0010EF  2  00 11 11 00  
0010F3  2  00 00 00 00  
00110B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00
00110F  2  00 11 11 00  
001113  2  00 00 00 00  
00112B  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
00112F  2  11 00 00 00  
001133  2  00 00 00 00  
00114B  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
00114F  2  11 00 00 00  
001153  2  00 00 00 00  
00116B  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
00116F  2  00 00 00 00  
001173  2  00 00 00 00  
00118B  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
00118F  2  00 00 00 00  
001193  2  00 00 00 00  
0011AB  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $11, $00
0011AF  2  00 00 00 00  
0011B3  2  00 00 00 00  
0011CB  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $11, $00
0011CF  2  00 00 00 00  
0011D3  2  00 00 00 00  
0011EB  2  00 11 00 11      .byte $00, $11, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $11, $00
0011EF  2  11 11 00 00  
0011F3  2  00 00 00 00  
00120B  2  00 11 00 11      .byte $00, $11, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $11, $00
00120F  2  11 11 00 00  
001213  2  00 00 00 00  
00122B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $11, $00
00122F  2  00 00 11 11  
001233  2  11 00 00 00  
00124B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $11, $00
00124F  2  00 00 11 11  
001253  2  11 00 00 00  
00126B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00126F  2  00 00 00 00  
001273  2  00 11 11 11  
00128B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00128F  2  00 00 00 00  
001293  2  00 11 11 11  
0012AB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0012AF  2  00 00 00 00  
0012B3  2  00 00 00 00  
0012CB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0012CF  2  00 00 00 00  
0012D3  2  00 00 00 00  
0012EB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0012EF  2  00 00 00 00  
0012F3  2  00 00 00 00  
00130B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00130F  2  00 00 00 00  
001313  2  00 00 00 00  
00132B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00132F  2  00 00 00 00  
001333  2  00 00 00 00  
00134B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00134F  2  00 00 00 00  
001353  2  00 00 00 00  
00136B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00136F  2  00 00 00 00  
001373  2  00 00 00 00  
00138B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00138F  2  00 00 00 00  
001393  2  00 00 00 00  
0013AB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0013AF  2  00 00 00 00  
0013B3  2  00 00 00 00  
0013CB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0013CF  2  00 00 00 00  
0013D3  2  00 00 00 00  
0013EB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0013EF  2  00 00 00 00  
0013F3  2  00 00 00 00  
00140B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00140F  2  00 00 00 00  
001413  2  00 00 00 00  
00142B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00142F  2  00 00 00 00  
001433  2  00 00 00 00  
00144B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00144F  2  00 00 00 00  
001453  2  00 00 00 00  
00146B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00146F  2  00 00 00 00  
001473  2  00 00 00 00  
00148B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00148F  2  00 00 00 00  
001493  2  00 00 00 00  
0014AB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0014AF  2  00 00 00 00  
0014B3  2  00 00 00 00  
0014CB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0014CF  2  00 00 00 00  
0014D3  2  00 00 00 00  
0014EB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0014EF  2  00 00 00 00  
0014F3  2  00 00 00 00  
00150B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00150F  2  00 00 00 00  
001513  2  00 00 00 00  
00152B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00152F  2  00 00 00 00  
001533  2  00 00 00 00  
00154B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00154F  2  00 00 00 00  
001553  2  00 00 00 00  
00156B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00156F  2  00 00 00 00  
001573  2  00 00 00 00  
00158B  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
00158F  2  00 00 00 00  
001593  2  00 00 00 00  
0015AB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00
0015AF  2  00 00 00 00  
0015B3  2  00 00 00 00  
0015CB  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00
0015CF  2  00 00 00 00  
0015D3  2  00 00 00 00  
0015EB  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00
0015EF  2  00 00 00 00  
0015F3  2  00 00 00 00  
00160B  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00
00160F  2  00 00 00 00  
001613  2  00 00 00 00  
00162B  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00
00162F  2  11 11 00 00  
001633  2  00 00 00 00  
00164B  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00
00164F  2  11 11 00 00  
001653  2  00 00 00 00  
00166B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00
00166F  2  00 00 11 11  
001673  2  11 00 00 00  
00168B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00
00168F  2  00 00 11 11  
001693  2  11 00 00 00  
0016AB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $11, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0016AF  2  00 00 00 00  
0016B3  2  00 11 11 11  
0016CB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $11, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0016CF  2  00 00 00 00  
0016D3  2  00 11 11 11  
0016EB  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0016EF  2  00 00 00 00  
0016F3  2  00 00 00 00  
00170B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00170F  2  00 00 00 00  
001713  2  00 00 00 00  
00172B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00172F  2  00 00 00 00  
001733  2  00 00 00 00  
00174B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00174F  2  00 00 00 00  
001753  2  00 00 00 00  
00176B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00176F  2  00 00 00 00  
001773  2  00 00 00 00  
00178B  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00178F  2  00 00 00 00  
001793  2  00 00 00 00  
0017AB  2               Race_car_end:
0017AB  2               
0017AB  2               Race_mountains_map:
0017AB  2               ; In row-major order
0017AB  2  00 00 00 00  .repeat 20, i
0017AF  2  00 00 00 00  
0017B3  2  00 00 00 00  
002BAB  2                   .repeat 128, j
002BAB  2                       .word $0000
002BAB  2                   .endrep
002BAB  2               .endrep
002BAB  2               
002BAB  2  01 00 01 00  .repeat 20, i
002BAF  2  01 00 01 00  
002BB3  2  01 00 01 00  
003FAB  2                   .repeat 128, j
003FAB  2                       .word $0001
003FAB  2                   .endrep
003FAB  2               .endrep
003FAB  2               
003FAB  2  02 00 02 00  .repeat 20, i
003FAF  2  02 00 02 00  
003FB3  2  02 00 02 00  
0053AB  2                   .repeat 128, j
0053AB  2                       .word $0002
0053AB  2                   .endrep
0053AB  2               .endrep
0053AB  2               
0053AB  2               ; ; In column-major order
0053AB  2               ; !for i, 1, 80 {
0053AB  2               ;     .word $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0001, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0003, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000
0053AB  2               ; }
0053AB  2               Race_mountains_map_end:
0053AB  2               Race_forest_map:
0053AB  2  01 01 01 01  .repeat 20, i
0053AF  2  01 01 01 01  
0053B3  2  01 01 01 01  
0067AB  2                   .repeat 128, j
0067AB  2                       .word $0101
0067AB  2                   .endrep
0067AB  2               .endrep
0067AB  2               
0067AB  2  01 01 01 01  .repeat 20, i
0067AF  2  01 01 01 01  
0067B3  2  01 01 01 01  
007BAB  2                   .repeat 128, j
007BAB  2                       .word $0101
007BAB  2                   .endrep
007BAB  2               .endrep
007BAB  2               
007BAB  2  01 01 01 01  .repeat 20, i
007BAF  2  01 01 01 01  
007BB3  2  01 01 01 01  
008FAB  2                   .repeat 128, j
008FAB  2                       .word $0101
008FAB  2                   .endrep
008FAB  2               .endrep
008FAB  2               
008FAB  2               Race_forest_map_end:
008FAB  2               
008FAB  2               .include "system.asm"
008FAB  3               .ifndef SYSTEM_ASM
008FAB  3               SYSTEM_ASM=1
008FAB  3               
008FAB  3               .include "system.inc"
008FAB  3               .include "vera.inc"
008FAB  3               
008FAB  3               ;=================================================
008FAB  3               ;=================================================
008FAB  3               ;
008FAB  3               ;   Random number generation
008FAB  3               ;
008FAB  3               ;-------------------------------------------------
008FAB  3               ;
008FAB  3               ; This random number generation routine is based
008FAB  3               ; on a linear feedback shift register, or LFSR.
008FAB  3               ; It's a common technique for generating complex
008FAB  3               ; sequences of values.
008FAB  3               ;
008FAB  3               ; This specific implementation is based on:
008FAB  3               ; https://wiki.nesdev.com/w/index.php/Random_number_generator/Linear_feedback_shift_register_(advanced)
008FAB  3               ;
008FAB  3               
008FAB  3               ;=================================================
008FAB  3               ; sys_rand
008FAB  3               ;   Generate an 8-bit random number.
008FAB  3               ;-------------------------------------------------
008FAB  3               ; INPUTS:   Sys_rand_mem
008FAB  3               ;
008FAB  3               ;-------------------------------------------------
008FAB  3               ; MODIFIES: A, X, Sys_rand_mem
008FAB  3               ;
008FAB  3               sys_rand:
008FAB  3                   ldx #8
008FAB  3                   lda Sys_rand_mem
008FAB  3               :   asl
008FAB  3                   rol Sys_rand_mem+1
008FAB  3                   rol Sys_rand_mem+2
008FAB  3                   bcc :+
008FAB  3                   eor #$1B
008FAB  3               :   dex
008FAB  3                   bne :--
008FAB  3                   sta Sys_rand_mem
008FAB  3                   cmp #0
008FAB  3                   rts
008FAB  3               ;=================================================
008FAB  3               ; sys_wait_one_frame
008FAB  3               ;   Wait for a new frame
008FAB  3               ;-------------------------------------------------
008FAB  3               ; INPUTS:   (none)
008FAB  3               ;
008FAB  3               ;-------------------------------------------------
008FAB  3               ; MODIFIES: A, X, Sys_frame
008FAB  3               ;
008FAB  3               sys_wait_one_frame:
008FAB  3                   lda #1
008FAB  3                   jsr sys_wait_for_frame
008FAB  3                   rts
008FAB  3               
008FAB  3               ;=================================================
008FAB  3               ; sys_wait_for_frame
008FAB  3               ;   Wait for a new frame
008FAB  3               ;-------------------------------------------------
008FAB  3               ; INPUTS:   A   number of frames to wait
008FAB  3               ;
008FAB  3               ;-------------------------------------------------
008FAB  3               ; MODIFIES: A, X, Sys_frame
008FAB  3               ;
008FAB  3               sys_wait_for_frame:
008FAB  3                   clc
008FAB  3                   adc Sys_frame
008FAB  3                   tax
008FAB  3               
008FAB  3                   SYS_SET_IRQ sys_inc_frame
008FAB  3                   cli
008FAB  3               
008FAB  3                   ; Tight loop until next frame
008FAB  3               :   cpx Sys_frame
008FAB  3                   bne :-
008FAB  3               
008FAB  3                   sei
008FAB  3                   rts
008FAB  3               
008FAB  3               ;=================================================
008FAB  3               ; sys_inc_frame
008FAB  3               ;   Increment a value when a new frame arrives
008FAB  3               ;-------------------------------------------------
008FAB  3               ; INPUTS:   (none)
008FAB  3               ;
008FAB  3               ;-------------------------------------------------
008FAB  3               ; MODIFIES: New_frame
008FAB  3               ;
008FAB  3               sys_inc_frame:
008FAB  3                   inc Sys_frame
008FAB  3                   VERA_END_IRQ
008FAB  3                   SYS_END_IRQ
008FAB  3               
008FAB  3               .endif ; SYSTEM_ASM
008FAB  3               
008FAB  2               .endif ; RACE_ASM
008FAB  2               
008FAB  1               .include "vera.asm"
008FAB  2               .ifndef VERA_ASM
008FAB  2               VERA_ASM=1
008FAB  2               
008FAB  2               ;==============================================
008FAB  2               ; vera_stream_out_data
008FAB  2               ; Stream out a block of memory to VERA_data
008FAB  2               ;----------------------------------------------
008FAB  2               ; INPUT: X   - number of pages to stream
008FAB  2               ;        Y   - number of bytes to stream
008FAB  2               ;        $FB - low byte of starting address
008FAB  2               ;        $FC - high byte of starting address
008FAB  2               ;----------------------------------------------
008FAB  2               ; Modifies: A, X, Y, $FC
008FAB  2               ;
008FAB  2               vera_stream_out_data:
008FAB  2  98               tya
008FAC  2  48               pha
008FAD  2                   ; If no pages to copy, skip to bytes
008FAD  2  8A               txa
008FAE  2  C9 00            cmp #0
008FB0  2  AA               tax
008FB1  2  F0 0F            beq @no_blocks
008FB3  2               
008FB3  2                   ; Copy X pages to VERA_data
008FB3  2  A0 00            ldy #0
008FB5  2               @loop:
008FB5  2  B1 FB            lda ($FB),Y
008FB7  2  8D 23 9F         sta VERA_data
008FBA  2  C8               iny
008FBB  2  D0 F8            bne @loop
008FBD  2               
008FBD  2  E6 FC            inc $FC
008FBF  2  CA               dex
008FC0  2  D0 F3            bne @loop
008FC2  2               
008FC2  2               @no_blocks:
008FC2  2                   ; Copy X bytes to VERA_data
008FC2  2  68               pla
008FC3  2  AA               tax
008FC4  2  A0 00            ldy #0
008FC6  2               @loop2:
008FC6  2  B1 FB            lda ($FB),Y
008FC8  2  8D 23 9F         sta VERA_data
008FCB  2  C8               iny
008FCC  2  CA               dex
008FCD  2  D0 F7            bne @loop2
008FCF  2  60               rts
008FD0  2               
008FD0  2               .endif ; VERA_ASM
008FD0  2               
008FD0  1               
008FD0  1               ;=================================================
008FD0  1               ;=================================================
008FD0  1               ;
008FD0  1               ;   Data
008FD0  1               ;
008FD0  1               ;-------------------------------------------------
008FD0  1               Petscii_table:
008FD0  1  00 01 02 03      .repeat $60, i
008FD4  1  04 05 06 07  
008FD8  1  08 09 0A 0B  
009030  1                       .byte i
009030  1                   .endrep
009030  1               
009030  1  A0 A1 A2 A3      .repeat $20, i
009034  1  A4 A5 A6 A7  
009038  1  A8 A9 AA AB  
009050  1                       .byte i+$A0
009050  1                   .endrep
009050  1               
009050  1               Matrix_palette:
009050  1  00 00 00 00      .word $0000, $0000, $0020, $0020, $0030, $0030, $0040, $0040
009054  1  20 00 20 00  
009058  1  30 00 30 00  
009060  1  50 00 50 00      .word $0050, $0050, $0060, $0060, $0070, $0070, $0080, $0080
009064  1  60 00 60 00  
009068  1  70 00 70 00  
009070  1  90 00 90 00      .word $0090, $0090, $00A0, $00A0, $00B0, $00B0, $00C0, $00C0
009074  1  A0 00 A0 00  
009078  1  B0 00 B0 00  
009080  1  D0 00 D0 00      .word $00D0, $00D0, $00E0, $00E0, $00F0, $00F0, $08FC
009084  1  E0 00 E0 00  
009088  1  F0 00 F0 00  
00908E  1               Matrix_palette_end:
00908E  1               Matrix_palette_rev:
00908E  1  00 00 00 00      .word $0000, $0000, $08FC, $00F0, $00F0, $00E0, $00E0, $00D0
009092  1  FC 08 F0 00  
009096  1  F0 00 E0 00  
00909E  1  D0 00 C0 00      .word $00D0, $00C0, $00C0, $00B0, $00B0, $00A0, $00A0, $0090
0090A2  1  C0 00 B0 00  
0090A6  1  B0 00 A0 00  
0090AE  1  90 00 80 00      .word $0090, $0080, $0080, $0070, $0070, $0060, $0060, $0050
0090B2  1  80 00 70 00  
0090B6  1  70 00 60 00  
0090BE  1  50 00 40 00      .word $0050, $0040, $0040, $0030, $0030, $0020, $0020
0090C2  1  40 00 30 00  
0090C6  1  30 00 20 00  
0090CC  1               Matrix_palette_rev_end:
0090CC  1               
0090CC  1               ;=================================================
0090CC  1               ;=================================================
0090CC  1               ;
0090CC  1               ;   Variables
0090CC  1               ;
0090CC  1               ;-------------------------------------------------
0090CC  1               .include "x16-racer_vars.asm"
0090CC  2               ; .ifdef X16_RACER_VARIABLES_ASM !eof
0090CC  2               ; X16_RACER_VARIABLES_ASM=1
0090CC  2               
0090CC  2  00           Palette_cycle_index: .byte $00
0090CD  2               
0090CD  1               .include "splash_vars.asm"
0090CD  2               .ifndef SPLASH_VARS_ASM
0090CD  2               SPLASH_VARS_ASM=1
0090CD  2               
0090CD  2               .if (GIANT_SPLASH = 0)
0090CD  2               Splash_logo:
0090CD  2                   .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $00, $00, $01, $11, $00, $00, $00, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $00, $01, $10, $00, $11, $10, $00, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $01, $10, $00, $00, $00, $01, $11, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $01, $10, $00, $00, $00, $00, $00, $00, $11, $10, $00, $00, $00
0090CD  2                   .byte $00, $00, $01, $10, $00, $00, $00, $00, $00, $00, $00, $00, $01, $11, $00, $00
0090CD  2                   .byte $00, $01, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $10
0090CD  2                   .byte $01, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $10
0090CD  2                   .byte $01, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $10
0090CD  2                   .byte $01, $01, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $11, $10, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $01, $11, $00, $00, $00, $00, $11, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $11, $10, $00, $11, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $01, $11, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $10
0090CD  2                   .byte $01, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $11, $00
0090CD  2                   .byte $01, $10, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $00, $11, $00, $00
0090CD  2                   .byte $00, $01, $11, $00, $00, $00, $00, $00, $01, $00, $00, $00, $11, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $11, $10, $00, $00, $00, $01, $00, $00, $11, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $01, $11, $00, $00, $01, $00, $11, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $00, $00, $11, $10, $01, $11, $00, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $00, $00, $00, $01, $11, $00, $00, $00, $00, $00, $00, $00
0090CD  2                   .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0090CD  2               Splash_logo_end:
0090CD  2               
0090CD  2               .else
0090CD  2               Splash_logo:
0090CD  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0090D1  2  00 00 00 00  
0090D5  2  00 00 00 00  
0090ED  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0090F1  2  00 00 00 00  
0090F5  2  00 00 00 00  
00910D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009111  2  00 00 00 00  
009115  2  00 00 00 00  
00912D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009131  2  00 00 00 00  
009135  2  00 00 00 00  
00914D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009151  2  00 00 00 00  
009155  2  00 00 00 11  
00916D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009171  2  00 00 00 00  
009175  2  00 00 00 11  
00918D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009191  2  00 00 00 00  
009195  2  00 11 11 00  
0091AD  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0091B1  2  00 00 00 00  
0091B5  2  00 11 11 00  
0091CD  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00
0091D1  2  00 00 00 11  
0091D5  2  11 00 00 00  
0091ED  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00
0091F1  2  00 00 00 11  
0091F5  2  11 00 00 00  
00920D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00
009211  2  00 11 11 00  
009215  2  00 00 00 00  
00922D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00
009231  2  00 11 11 00  
009235  2  00 00 00 00  
00924D  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
009251  2  11 00 00 00  
009255  2  00 00 00 00  
00926D  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
009271  2  11 00 00 00  
009275  2  00 00 00 00  
00928D  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
009291  2  00 00 00 00  
009295  2  00 00 00 00  
0092AD  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00
0092B1  2  00 00 00 00  
0092B5  2  00 00 00 00  
0092CD  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $11, $00
0092D1  2  00 00 00 00  
0092D5  2  00 00 00 00  
0092ED  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $11, $00
0092F1  2  00 00 00 00  
0092F5  2  00 00 00 00  
00930D  2  00 11 00 11      .byte $00, $11, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $11, $00
009311  2  11 11 00 00  
009315  2  00 00 00 00  
00932D  2  00 11 00 11      .byte $00, $11, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $11, $00
009331  2  11 11 00 00  
009335  2  00 00 00 00  
00934D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $11, $00
009351  2  00 00 11 11  
009355  2  11 00 00 00  
00936D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $11, $00
009371  2  00 00 11 11  
009375  2  11 00 00 00  
00938D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009391  2  00 00 00 00  
009395  2  00 11 11 11  
0093AD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0093B1  2  00 00 00 00  
0093B5  2  00 11 11 11  
0093CD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0093D1  2  00 00 00 00  
0093D5  2  00 00 00 00  
0093ED  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0093F1  2  00 00 00 00  
0093F5  2  00 00 00 00  
00940D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009411  2  00 00 00 00  
009415  2  00 00 00 00  
00942D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009431  2  00 00 00 00  
009435  2  00 00 00 00  
00944D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009451  2  00 00 00 00  
009455  2  00 00 00 00  
00946D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009471  2  00 00 00 00  
009475  2  00 00 00 00  
00948D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009491  2  00 00 00 00  
009495  2  00 00 00 00  
0094AD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0094B1  2  00 00 00 00  
0094B5  2  00 00 00 00  
0094CD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0094D1  2  00 00 00 00  
0094D5  2  00 00 00 00  
0094ED  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0094F1  2  00 00 00 00  
0094F5  2  00 00 00 00  
00950D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009511  2  00 00 00 00  
009515  2  00 00 00 00  
00952D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009531  2  00 00 00 00  
009535  2  00 00 00 00  
00954D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009551  2  00 00 00 00  
009555  2  00 00 00 00  
00956D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009571  2  00 00 00 00  
009575  2  00 00 00 00  
00958D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009591  2  00 00 00 00  
009595  2  00 00 00 00  
0095AD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0095B1  2  00 00 00 00  
0095B5  2  00 00 00 00  
0095CD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0095D1  2  00 00 00 00  
0095D5  2  00 00 00 00  
0095ED  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0095F1  2  00 00 00 00  
0095F5  2  00 00 00 00  
00960D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009611  2  00 00 00 00  
009615  2  00 00 00 00  
00962D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009631  2  00 00 00 00  
009635  2  00 00 00 00  
00964D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009651  2  00 00 00 00  
009655  2  00 00 00 00  
00966D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009671  2  00 00 00 00  
009675  2  00 00 00 00  
00968D  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
009691  2  00 00 00 00  
009695  2  00 00 00 00  
0096AD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00
0096B1  2  00 00 00 00  
0096B5  2  00 00 00 00  
0096CD  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00
0096D1  2  00 00 00 00  
0096D5  2  00 00 00 00  
0096ED  2  00 11 00 00      .byte $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00
0096F1  2  00 00 00 00  
0096F5  2  00 00 00 00  
00970D  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00
009711  2  00 00 00 00  
009715  2  00 00 00 00  
00972D  2  00 11 11 00      .byte $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00
009731  2  00 00 00 00  
009735  2  00 00 00 00  
00974D  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00
009751  2  11 11 00 00  
009755  2  00 00 00 00  
00976D  2  00 00 00 11      .byte $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00
009771  2  11 11 00 00  
009775  2  00 00 00 00  
00978D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00
009791  2  00 00 11 11  
009795  2  11 00 00 00  
0097AD  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00
0097B1  2  00 00 11 11  
0097B5  2  11 00 00 00  
0097CD  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $11, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0097D1  2  00 00 00 00  
0097D5  2  00 11 11 11  
0097ED  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $11, $00, $00, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0097F1  2  00 00 00 00  
0097F5  2  00 11 11 11  
00980D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009811  2  00 00 00 00  
009815  2  00 00 00 00  
00982D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009831  2  00 00 00 00  
009835  2  00 00 00 00  
00984D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009851  2  00 00 00 00  
009855  2  00 00 00 00  
00986D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $11, $11, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009871  2  00 00 00 00  
009875  2  00 00 00 00  
00988D  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
009891  2  00 00 00 00  
009895  2  00 00 00 00  
0098AD  2  00 00 00 00      .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0098B1  2  00 00 00 00  
0098B5  2  00 00 00 00  
0098CD  2               Splash_logo_end:
0098CD  2               .endif
0098CD  2               
0098CD  2               .endif ; SPLASH_VARS_ASM
0098CD  2               
0098CD  1               .include "graphics_vars.asm"
0098CD  2               ; .ifdef GRAPHICS_VARS_ASM !eof
0098CD  2               ; GRAPHICS_VARS_ASM=1
0098CD  2               
0098CD  2  00           Gfx_all_palettes_cleared: .byte $00
0098CE  2  00 00        Gfx_fade_palette_addr: .word $0000
0098D0  2  00           Gfx_fade_palette_count: .byte $00
0098D1  2               
0098D1  1               .include "system_vars.asm"
0098D1  2               .ifndef SYSTEM_VARS_ASM
0098D1  2               SYSTEM_VARS_ASM=1
0098D1  2               
0098D1  2  00 00 00     Sys_rand_mem: .byte $00, $00, $00
0098D4  2  00           Sys_frame: .byte $00
0098D5  2               Sys_mem_end:
0098D5  2               
0098D5  2               .endif ; SYSTEM_VARS_ASM
0098D5  2               
0098D5  1               
0098D5  1               SYS_FOOTER
0098D5  1               
